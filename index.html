<!DOCTYPE html>
<!--
    This file is genereted by build.js. ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ build.js ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚
    build options: ../build.json all
    build at: Thu Jan 15 2026 10:18:35 GMT+0900 (æ—¥æœ¬æ¨™æº–æ™‚)
    repository: https://github.com/wraith13/myaku-myaku-sama/
-->
<!-- license:
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<title>Myaku-Myaku Sama</title>
<link id="favicon" rel="shortcut icon" href="./image/favicon.png">
<link rel="canonical" href="https://wraith13.github.io/myaku-myaku-sama/">
<link rel="apple-touch-icon" href="./image/favicon.png">
<meta name="theme-color" content="black">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<meta name="description" lang="ja" content="Myaku-Myaku Sama's pattern animation ( this web app is for study )">
<link id="manifest" rel="manifest" href="web.manifest.json" />
<meta name="apple-mobile-web-app-title" content="Myaku-Myaku Sama">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="mobile-web-app-capable" content="yes">
<meta name="twitter:card" content="player">
<meta name="twitter:site" content="@wraith13">
<!-- meta name="twitter:creator" content="@wraith13" -->
<meta name="twitter:title" content="Myaku-Myaku Sama">
<meta name="twitter:description" lang="en" content="Myaku-Myaku Sama's pattern animation ( this web app is for study )">
<meta name="twitter:image" content="https://wraith13.github.io/myaku-myaku-sama/image/twitter-card.png">
<meta name="twitter:player" content="https://wraith13.github.io/myaku-myaku-sama/#twitter-card-player">
<meta name="twitter:player:width" content="600">
<meta name="twitter:player:height" content="600">
<meta property="og:title" content="Myaku-Myaku Sama" />
<meta property="og:description" content="Myaku-Myaku Sama's pattern animation ( this web app is for study )" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://wraith13.github.io/myaku-myaku-sama/" />
<meta property="og:image" content="https://wraith13.github.io/myaku-myaku-sama/image/twitter-card.png" />
<meta property="og:image:width" content="1200" />
<meta property="og:image:height" content="630" />
<meta property="og:site_name" content="Myaku-Myaku Sama" />
<meta property="og:locale" content="en_US" />
<link rel="image_src" href="https://wraith13.github.io/myaku-myaku-sama/image/twitter-card.png" />
<style>
@property --short-side
{
    syntax: '<length>';
    inherits: true;
    initial-value: min(1vw, 1vh);
}
@property --low
{
    syntax: '<number>';
    inherits: true;
    initial-value: 0;
}
@property --high
{
    syntax: '<number>';
    inherits: true;
    initial-value: 0;
}
@property --rotate
{
    syntax: '<number>';
    inherits: true;
    initial-value: 0;
}
*
{
    box-sizing: border-box;
}
html, body, canvas
{
    height: 100%;
    min-height: 100vh;
    min-height: 100lvh;
    max-height: 100vh;
    max-height: 100lvh;
    width: 100%;
    min-width: 100vw;
    min-width: 100lvw;
    max-width: 100vw;
    max-width: 100lvw;
}
html, body
{
    margin: 0px;
    padding: 0px;
    overflow: visible;
}
canvas
{
    position: fixed;
    inset: 0px;
    image-rendering: pixelated;
}
body:not(.mousemove)
{
    cursor: none;
}
#overlay-panel
{
    position: fixed;
    user-select: none;
    pointer-events: none;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border-radius: calc(2 * var(--short-side));
    backdrop-filter: blur(calc(1 * var(--short-side)));
}
#overlay-panel.zebra::after
{
    content: "";
    position: absolute;
    inset: 0;
    pointer-events: none;
    backdrop-filter: invert(1);
    mask-image: linear-gradient(var(--angle, 45deg), transparent 50%, white 50%);
}
time
{
    display: block;
    text-align: center;
}
#time
{
    font-family: "Consolas", "Liberation Mono", "Courier New", monospace;
    font-size: calc(14.8 * var(--short-side));
    line-height: 100%;
    white-space: nowrap;
}
#date
{
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
    font-size: calc(4.2 * var(--short-side));
    line-height: 100%;
    white-space: nowrap;
}
.white time,
.rainbow time,
.zebra time
{
    color: white;
    text-shadow: -1px -1px 0px black, 1px -1px 0px black, -1px 1px 0px black, 1px 1px 0px black;
}
.black time
{
    color: black;
    text-shadow: -1px -1px 0px white, 1px -1px 0px white, -1px 1px 0px white, 1px 1px 0px white;
}
#fps
{
    position: fixed;
    z-index: 100;
    top: 0.5rem;
    top: max(0.5rem, env(safe-area-inset-top, 0.5rem));
    left: 0.5rem;
    left: max(0.5rem, env(safe-area-inset-left, 0.5rem));
    color: white;
    background-color: rgba(0, 0, 0, 0.5);
    font-family: monospace;
    font-size: 12px;
    padding: 0.25rem 0.5rem;
    border-radius: 0.5rem;
    white-space: pre;
    backdrop-filter: blur(0.5rem);
}
body:not(.mousemove) #control-panel
{
    opacity: 0;
    transition: opacity 1.5s ease;
}
#control-panel
{
    position: fixed;
    z-index: 100;
    bottom: 0.5rem;
    bottom: max(0.5rem, env(safe-area-inset-bottom, 0.5rem));
    right: 0.5rem;
    right: max(0.5rem, env(safe-area-inset-right, 0.5rem));
    color: white;
    background-color: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(0.5rem);
    padding: 0.25rem;
    border-radius: 2rem;
    display: flex;
    flex-direction: row;
    transition: opacity 0.5s ease;
}
button
{
    position: relative;
    background-color: rgba(0, 0, 0, 0.5);
    border-radius: 50%;
    height: 3rem;
    width: 3rem;
    padding: calc(0.5rem - 4px);
    border-width: 4px;
    border-style: solid;
    border-color: black;
    transition: border-color 0.5s ease;
    color: white;
}
svg
{
    position: relative;
    height: 2.0rem;
    width: 2.0rem;
    color: white;
    fill: white;
}
svg path
{
    color: white !important;
    fill: white !important;
}
button.round-bar::before
{
    position: absolute;
    content: "";
    height: 3rem;
    width: 3rem;
    top: -4px;
    left: -4px;
    transition: --low 0.5s ease, --high 0.5s ease, --rotate 0.5s ease;
    border-radius: 50%;
    mask-image: radial-gradient(circle at center, transparent 0%, transparent calc(70.71% - 4px), white calc(70.71% - 4px));
    background:
        radial-gradient(circle at center, black 0%, black calc(70.71% - 4px), transparent calc(70.71% - 4px)), /* This radial-gradient is a fallback for older environments */
        conic-gradient(black 0deg, black calc(var(--low) * 360deg),  white calc(var(--low) * 360deg),  white calc(var(--high) * 360deg), white calc(var(--high) * 360deg), black calc(var(--high) * 360deg));
    transform: rotate(calc(var(--rotate) * 360deg));
}
button.on
{
    border-color: white;
}
button:focus
{
    outline: none;
    background-color: hsla(200, 100%, 35%, 0.9);
}
@media (hover: hover)
{
    button:hover
    {
        background-color: hsla(100, 100%, 25%, 0.9);
    }
}

</style>
</head>
<body>
<noscript id="noscript" role="presentation">
    <div class="panel" role="presentation">
        <div class="section" role="presentation">
            <h2>NOSCRIPT</h2>
            JavaScript is disabled. Please enable JavaScript.
        </div>
    </div>
</noscript>
<canvas id="canvas" role="presentation"></canvas>
<div id="overlay-panel" role="presentation" class="black">
    <time id="time" role="timer" aria-live="polite" aria-atomic="true"></time>
    <time id="date" aria-live="polite" aria-atomic="true"></time>
</div>
<div id="fps" aria-hidden="true"></div>
<div id="control-panel" aria-label="Control Panel" title="Control Panel">
    <button id="coloring-button" class="round-bar" aria-label="Change Coloring" title="Change Coloring(C)" aria-keyshortcuts="C"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg role="presentation" aria-hidden="true" width="100%" height="100%" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(1.2381,0,0,1.2381,16.7619,16.7619)">
        <path d="M378.182,735.302C202.891,724.044 64,578.114 64,400C64,214.557 214.557,64 400,64C585.443,64 736,214.557 736,400C736,407.836 735.731,415.611 735.202,423.314C733.374,449.93 728.441,475.697 720.763,500.257C718.312,500.188 715.852,500.154 713.385,500.154C685.114,500.154 657.897,504.703 632.427,513.108C565.915,535.056 511.315,583.301 480.958,645.508C468.078,671.901 459.563,700.808 456.354,731.286C438.029,734.386 419.201,736 400,736C392.671,736 385.396,735.765 378.182,735.302ZM510.689,490.695C552.829,458.752 602.723,436.516 657.031,427.329C657.977,418.348 658.462,409.23 658.462,400C658.462,257.351 542.649,141.538 400,141.538C257.351,141.538 141.538,257.351 141.538,400C141.538,540.181 253.379,654.447 392.622,658.358C413.27,592.315 453.772,535.006 507.124,493.434C508.257,492.455 509.447,491.54 510.689,490.695ZM400,180.308C421.397,180.308 438.769,197.68 438.769,219.077C438.769,240.474 421.397,257.846 400,257.846C378.603,257.846 361.231,240.474 361.231,219.077C361.231,197.68 378.603,180.308 400,180.308ZM219.077,361.231C240.474,361.231 257.846,378.603 257.846,400C257.846,421.397 240.474,438.769 219.077,438.769C197.68,438.769 180.308,421.397 180.308,400C180.308,378.603 197.68,361.231 219.077,361.231ZM267.538,484C288.936,484 306.308,501.372 306.308,522.769C306.308,544.167 288.936,561.538 267.538,561.538C246.141,561.538 228.769,544.167 228.769,522.769C228.769,501.372 246.141,484 267.538,484ZM474.308,341.846C506.404,341.846 532.462,367.904 532.462,400C532.462,432.096 506.404,458.154 474.308,458.154C442.212,458.154 416.154,432.096 416.154,400C416.154,367.904 442.212,341.846 474.308,341.846ZM580.923,361.231C602.32,361.231 619.692,378.603 619.692,400C619.692,421.397 602.32,438.769 580.923,438.769C559.526,438.769 542.154,421.397 542.154,400C542.154,378.603 559.526,361.231 580.923,361.231ZM267.538,238.462C288.936,238.462 306.308,255.833 306.308,277.231C306.308,298.628 288.936,316 267.538,316C246.141,316 228.769,298.628 228.769,277.231C228.769,255.833 246.141,238.462 267.538,238.462ZM532.462,238.462C553.859,238.462 571.231,255.833 571.231,277.231C571.231,298.628 553.859,316 532.462,316C511.064,316 493.692,298.628 493.692,277.231C493.692,255.833 511.064,238.462 532.462,238.462Z"/>
    </g>
</svg>
</button>
    <button id="hd-button" class="round-bar" aria-label="Change Quality" title="Change Quality(Q)" aria-keyshortcuts="Q"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg role="presentation" aria-hidden="true" width="100%" height="100%" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(1.18182,0,0,1,-93.0909,-96)">
        <path d="M864,412.755L864,803.245C864,836.776 840.965,864 812.592,864L211.408,864C183.035,864 160,836.776 160,803.245L160,412.755C160,379.224 183.035,352 211.408,352L812.592,352C840.965,352 864,379.224 864,412.755ZM302.154,752L356.308,752L356.308,640L440.923,640L440.923,752L495.077,752L495.077,464L440.923,464L440.923,576L356.308,576L356.308,464L302.154,464L302.154,752ZM545.846,752L627.077,752C694.326,752 748.923,687.476 748.923,608C748.923,528.524 694.326,464 627.077,464L545.846,464L545.846,752ZM600,528L627.077,528C664.437,528 694.769,563.847 694.769,608C694.769,652.153 664.437,688 627.077,688L600,688L600,528Z"/>
    </g>
</svg>
</button>
    <button id="pitch-button" class="round-bar" aria-label="Change Pitch" title="Change Pitch(P)" aria-keyshortcuts="P"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg role="presentation" aria-hidden="true" width="100%" height="100%" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(6.12323e-17,1,-1.09091,6.67989e-17,1005.09,72)">
        <path d="M188,628L188,657.333L92,657.333L92,246.667L188,246.667L188,276L296,276C310.54,276 323.578,281.939 332.384,291.312L440.009,389.852L547.197,291.765C556.005,282.131 569.227,276 584,276L692,276L692,246.667L788,246.667L788,657.333L692,657.333L692,628L584,628C569.73,628 556.906,622.279 548.11,613.206L439.991,514.213L332.407,612.663C323.601,622.051 310.552,628 296,628L188,628ZM188,364L188,540L275.931,540L372.069,452.024L275.928,364L188,364ZM604.141,364L507.931,452.041L604,540L692,540L692,364L604.141,364Z"/>
    </g>
</svg>
</button>
    <button id="watch-button" class="round-bar" aria-label="Show Watch" title="Show Watch(W)" aria-keyshortcuts="W"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg role="presentation" aria-hidden="true" width="100%" height="100%" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <path d="M512,96C741.597,96 928,282.403 928,512C928,741.597 741.597,928 512,928C282.403,928 96,741.597 96,512C96,282.403 282.403,96 512,96ZM512,192C688.613,192 832,335.387 832,512C832,688.613 688.613,832 512,832C335.387,832 192,688.613 192,512C192,335.387 335.387,192 512,192ZM503.806,508.395L662.473,349.917C681.066,331.345 711.239,331.363 729.811,349.957L730.354,350.501C748.926,369.095 748.908,399.268 730.314,417.839L539.166,608.761C538.717,609.249 538.254,609.732 537.778,610.208C530.727,617.263 522.02,621.663 512.902,623.408L512.727,623.441L512.644,623.456L512.605,623.464L512.535,623.476L512.443,623.493L512.386,623.504L512.31,623.518L512.198,623.537L512.159,623.544L512.129,623.549L512.014,623.569L511.872,623.593C510.28,623.863 508.661,624.054 507.02,624.162L506.898,624.17L506.756,624.179L506.72,624.181L506.691,624.183L506.592,624.189L506.483,624.195L506.432,624.198L506.381,624.2L506.286,624.205L506.203,624.209L506.144,624.212L506.067,624.216L505.979,624.22L505.919,624.222L505.857,624.225L505.751,624.229L505.672,624.233L505.63,624.234L505.569,624.236L505.43,624.241L505.364,624.243L505.337,624.244L505.281,624.246L505.104,624.251L505.055,624.252L505.041,624.252L504.993,624.254L504.768,624.258L504.742,624.259C504.438,624.265 504.133,624.268 503.829,624.268L503.817,624.268L503.685,624.267L503.553,624.267L503.541,624.267L503.507,624.267L503.295,624.265L503.26,624.264C498.449,624.21 493.806,623.446 489.434,622.072L489.338,622.042L489.266,622.019C482.181,619.773 475.514,615.843 469.896,610.229L341.788,482.199C323.05,463.472 323.041,433.055 341.768,414.316C360.495,395.578 390.912,395.569 409.65,414.296L503.806,508.395Z"/>
</svg>
</button>
    <button id="fps-button" aria-label="Show FPS" title="Show FPS(S)" aria-keyshortcuts="S"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg role="presentation" aria-hidden="true" width="100%" height="100%" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(1.2381,0,0,1.2381,16.7619,16.7619)">
        <path d="M179.265,653.243C108.649,591.628 64,500.987 64,400C64,214.557 214.557,64 400,64C585.443,64 736,214.557 736,400C736,500.987 691.351,591.628 620.735,653.243C561.677,704.772 484.456,736 400,736C315.544,736 238.323,704.772 179.265,653.243ZM570.885,593.846C615.433,554.538 646.347,500.129 655.584,438.664C635.528,437.189 619.692,420.429 619.692,400C619.692,379.571 635.528,362.811 655.584,361.336C649.205,318.887 632.487,279.804 608.079,246.736C601.083,253.606 591.494,257.846 580.923,257.846C559.526,257.846 542.154,240.474 542.154,219.077C542.154,208.506 546.394,198.917 553.264,191.921C520.196,167.513 481.113,150.795 438.664,144.416C437.189,164.472 420.429,180.308 400,180.308C379.571,180.308 362.811,164.472 361.336,144.416C318.887,150.795 279.804,167.513 246.736,191.921C253.606,198.917 257.846,208.506 257.846,219.077C257.846,240.474 240.474,257.846 219.077,257.846C208.506,257.846 198.917,253.606 191.921,246.736C167.513,279.804 150.795,318.887 144.416,361.336C164.472,362.811 180.308,379.571 180.308,400C180.308,420.429 164.472,437.189 144.416,438.664C153.653,500.129 184.567,554.538 229.115,593.846C273.758,554.454 332.094,530.227 396.025,529.261L487.13,315.774C495.462,296.251 518.075,287.165 537.598,295.497L538.169,295.741C557.692,304.072 566.778,326.685 558.447,346.208L475.548,540.465C511.209,551.364 543.604,569.773 570.885,593.846Z"/>
    </g>
</svg>
</button>
    <button id="fullscreen-button" aria-label="Toggle Fullscreen" title="Toggle Fullscreen(F)" aria-keyshortcuts="F"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg role="presentation" aria-hidden="true" width="100%" height="100%" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(1.44538,0,0,1.44538,-479.529,-17.0084)">
        <path d="M623.733,128L623.733,172.279L519.509,172.279C504.481,172.279 492.279,184.481 492.279,199.509L492.279,298.198L448,298.198L448,196.227C448,158.572 478.572,128 516.227,128L623.733,128ZM924,298.198L879.721,298.198L879.721,199.509C879.721,184.481 867.519,172.279 852.491,172.279L748.267,172.279L748.267,128L855.773,128C893.428,128 924,158.572 924,196.227L924,298.198ZM748.267,604L748.267,559.731L852.491,559.731C867.519,559.731 879.721,547.529 879.721,532.5L879.721,422.733L924,422.733L924,535.773C924,573.428 893.428,604 855.773,604L748.267,604ZM448,422.733L492.279,422.733L492.279,532.5C492.279,547.529 504.481,559.731 519.509,559.731L623.733,559.731L623.733,604L516.227,604C478.572,604 448,573.428 448,535.773L448,422.733Z"/>
    </g>
</svg>
</button>
    <button id="jump-out-button" aria-label="Open in New Tab" title="Open in New Tab"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg role="presentation" aria-hidden="true" width="100%" height="100%" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(1.44538,0,0,1.44538,-479.529,-17.0084)">
        <path d="M647.256,128L647.256,172.279L519.509,172.279C504.481,172.279 492.279,184.481 492.279,199.509L492.279,532.5C492.279,547.529 504.481,559.731 519.509,559.731L852.491,559.731C867.519,559.731 879.721,547.529 879.721,532.5L879.721,401.977L924,401.977L924,535.773C924,573.428 893.428,604 855.773,604L516.227,604C478.572,604 448,573.428 448,535.773L448,196.227C448,158.572 478.572,128 516.227,128L647.256,128ZM805.054,294.003L666.546,432.51C653.586,445.471 632.542,445.471 619.581,432.51C606.621,419.55 606.621,398.506 619.581,385.545L758.089,247.037L695.737,184.685C689.233,178.181 685.993,169.642 686.017,161.11L686.017,160.577C686.008,142.395 700.761,127.626 718.943,127.617L890.893,127.529C900.027,127.524 908.3,131.246 914.273,137.256C919.161,142.113 922.535,148.491 923.622,155.617C924.075,158.289 924.2,161.005 923.998,163.702L923.913,329.42C924.911,339.032 921.73,348.996 914.372,356.355C906.829,363.897 896.55,367.05 886.718,365.814C877.859,364.817 870.06,360.301 864.751,353.699L805.054,294.003Z"/>
    </g>
</svg>
</button>
</div>
<script type="text/javascript">
const build = {
    at: "Thu Jan 15 2026 10:18:35 GMT+0900 (æ—¥æœ¬æ¨™æº–æ™‚)",
    tick: 1768439915345
};
const evilCommonjsConfig = {
    "log": {
        "config": false,
        "load": false,
        "define": false,
        "readyToCapture": false,
        "results": false
    },
    "loadingTimeout": 500
}
; // "./resource/evil-commonjs.config.json"
const evilTimerConfig = {
    "debug": true
}
; // "./resource/evil-timer.js.config.json"
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
(function () {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    var pathStack = [];
    pathStack.push(location.href);
    var getBasePath = function () { return location.href; };
    var getCurrentPath = function () { var _a; return (_a = pathStack[pathStack.length - 1]) !== null && _a !== void 0 ? _a : location.href; };
    var loadScript = function (src) { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var script = document.createElement("script");
                    script.src = src;
                    script.onload = function () { return resolve(); };
                    script.onerror = reject;
                    document.head.appendChild(script);
                })];
        });
    }); };
    var loadJsonRaw = function (src) { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var request = new XMLHttpRequest();
                    request.open('GET', src, true);
                    request.onreadystatechange = function () {
                        if (4 === request.readyState) {
                            if (200 <= request.status && request.status < 300) {
                                try {
                                    resolve(JSON.parse(request.responseText));
                                }
                                catch (err) {
                                    reject(err);
                                }
                            }
                            else {
                                reject(request);
                            }
                        }
                    };
                    request.send(null);
                })];
        });
    }); };
    var makeAbsoluteUrl = function (path) {
        var mappedPath = resolveMapping(path);
        var base = mappedPath ? getBasePath() : getCurrentPath();
        var url = mappedPath !== null && mappedPath !== void 0 ? mappedPath : path;
        var baseParts = base.split("?")[0].split("/");
        if (4 <= baseParts.length && "" !== baseParts[baseParts.length - 1]) {
            // ãƒ•ã‚¡ã‚¤ãƒ«åéƒ¨åˆ†ã®é™¤åŽ»
            baseParts = baseParts.slice(0, -1);
        }
        if (4 <= baseParts.length && "" === baseParts[baseParts.length - 1]) {
            // æœ«å°¾ã®ç©ºè¦ç´ ã‚’é™¤åŽ»(ã—ã¦ãŠã‹ãªã„ã¨çµåˆæ™‚ã«ä½™åˆ†ã« / ãŒæŒŸã¾ã‚‹)
            baseParts = baseParts.slice(0, -1);
        }
        var urlParts = url.split("/");
        if (0 <= urlParts[0].indexOf(":")) {
            //  çµ¶å¯¾ãƒ‘ã‚¹ãªã®ã§ base å´ã¯å…¨ã¦ç ´æ£„
            baseParts = [];
        }
        else {
            if ("" === urlParts[0]) {
                urlParts = urlParts.slice(1);
                if ("" === urlParts[0]) {
                    //  ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã ã‘åˆ©ç”¨
                    baseParts = baseParts.slice(0, 1);
                }
                else {
                    //  ã‚µãƒ¼ãƒãƒ¼åã¾ã§åˆ©ç”¨
                    baseParts = baseParts.slice(0, 3);
                }
            }
            else {
                while (true) {
                    if ("." === urlParts[0]) {
                        urlParts = urlParts.slice(1);
                        continue;
                    }
                    if (".." === urlParts[0]) {
                        urlParts = urlParts.slice(1);
                        if (4 <= baseParts.length) {
                            baseParts = baseParts.slice(0, -1);
                        }
                        continue;
                    }
                    break;
                }
            }
        }
        return baseParts.concat(urlParts).join("/");
    };
    var evil = {
        unresolved: [],
        modules: {},
        mapping: {},
        module: {
            registerMapping: function (path, mapping) { return mapping.forEach(function (i) { return evil.mapping[i] = path; }); },
            load: function (path, mapping) { return __awaiter(_this, void 0, void 0, function () {
                var absolutePath, result, _a, _b, absolutePath, result;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            if (!/\.json(\?.*)?$/i.test(path)) return [3 /*break*/, 2];
                            if (mapping) {
                                evil.module.registerMapping(path, mapping);
                            }
                            absolutePath = makeAbsoluteUrl(path);
                            if (config.log.load) {
                                console.log("evil-commonjs: load(\"".concat(absolutePath, "\", ").concat(JSON.stringify(mapping), ")"));
                            }
                            _a = evil.modules;
                            _b = absolutePath;
                            return [4 /*yield*/, loadJsonRaw(absolutePath)];
                        case 1:
                            result = _a[_b] = _c.sent();
                            window.module.pauseCapture();
                            return [2 /*return*/, result];
                        case 2:
                            absolutePath = makeAbsoluteUrl(path);
                            _c.label = 3;
                        case 3:
                            _c.trys.push([3, , 5, 6]);
                            pathStack.push(absolutePath);
                            window.module.readyToCapture(absolutePath);
                            if (config.log.load) {
                                console.log("evil-commonjs: load(\"".concat(absolutePath, "\", ").concat(JSON.stringify(mapping), ")"));
                            }
                            return [4 /*yield*/, loadScript(absolutePath)];
                        case 4:
                            _c.sent();
                            return [3 /*break*/, 6];
                        case 5:
                            pathStack.pop();
                            return [7 /*endfinally*/];
                        case 6:
                            result = evil.module.capture(path, mapping);
                            return [2 /*return*/, result];
                    }
                });
            }); },
            sequentialLoad: function (map) { return __awaiter(_this, void 0, void 0, function () {
                var result, _a, _b, _c, _i, i, _d, _e;
                return __generator(this, function (_f) {
                    switch (_f.label) {
                        case 0:
                            result = [];
                            _a = map;
                            _b = [];
                            for (_c in _a)
                                _b.push(_c);
                            _i = 0;
                            _f.label = 1;
                        case 1:
                            if (!(_i < _b.length)) return [3 /*break*/, 4];
                            _c = _b[_i];
                            if (!(_c in _a)) return [3 /*break*/, 3];
                            i = _c;
                            _e = (_d = result).push;
                            return [4 /*yield*/, evil.module.load(map[i].path, map[i].mapping)];
                        case 2:
                            _e.apply(_d, [_f.sent()]);
                            _f.label = 3;
                        case 3:
                            _i++;
                            return [3 /*break*/, 1];
                        case 4: return [2 /*return*/, result];
                    }
                });
            }); },
            capture: function (path, mapping) {
                if (mapping) {
                    evil.module.registerMapping(path, mapping);
                }
                var absolutePath = makeAbsoluteUrl(path);
                window.module.exports.default = window.module.exports.default || window.module.exports;
                var result = evil.modules[absolutePath] = window.module.exports;
                window.module.pauseCapture();
                evil.unresolved = evil.unresolved.filter(function (i) { return i !== absolutePath; });
                return result;
            },
            readyToCapture: function (path) {
                if (config.log.readyToCapture) {
                    console.log("readyToCapture(\"".concat(path, "\")"));
                }
                window.module.exports = window.exports = {};
                if (path) {
                    var absolutePath = makeAbsoluteUrl(path);
                    if (evil.modules[absolutePath]) {
                        window.module.exports = window.exports = evil.modules[absolutePath];
                    }
                }
            },
            pauseCapture: function () { return window.exports = undefined; },
            exports: {},
        },
    };
    var resolveMapping = function (path) {
        return evil.mapping[path];
    };
    //const gThis = globalThis;
    var gThis = ((_a = self !== null && self !== void 0 ? self : window) !== null && _a !== void 0 ? _a : global);
    try {
        evilCommonjsConfig;
    }
    catch (_l) {
        evilCommonjsConfig = undefined;
    }
    var config = {
        log: {
            config: true === ((_b = evilCommonjsConfig === null || evilCommonjsConfig === void 0 ? void 0 : evilCommonjsConfig.log) === null || _b === void 0 ? void 0 : _b.config),
            load: false !== ((_c = evilCommonjsConfig === null || evilCommonjsConfig === void 0 ? void 0 : evilCommonjsConfig.log) === null || _c === void 0 ? void 0 : _c.load),
            define: false !== ((_d = evilCommonjsConfig === null || evilCommonjsConfig === void 0 ? void 0 : evilCommonjsConfig.log) === null || _d === void 0 ? void 0 : _d.define),
            readyToCapture: false !== ((_e = evilCommonjsConfig === null || evilCommonjsConfig === void 0 ? void 0 : evilCommonjsConfig.log) === null || _e === void 0 ? void 0 : _e.readyToCapture),
            results: true === ((_f = evilCommonjsConfig === null || evilCommonjsConfig === void 0 ? void 0 : evilCommonjsConfig.log) === null || _f === void 0 ? void 0 : _f.results),
        },
        loadingTimeout: "number" === typeof (evilCommonjsConfig === null || evilCommonjsConfig === void 0 ? void 0 : evilCommonjsConfig.loadingTimeout) ? evilCommonjsConfig.loadingTimeout : 1500,
    };
    try {
        var urlConfig = (_k = (_j = (_h = (_g = location.href
            .split("#")[0]
            .split("?")[1]) === null || _g === void 0 ? void 0 : _g.split("&")) === null || _h === void 0 ? void 0 : _h.filter(function (i) { return i.startsWith("evil-commonjs="); })) === null || _j === void 0 ? void 0 : _j.map(function (i) { return JSON.parse(decodeURIComponent(i.substring("evil-commonjs=".length))); })) === null || _k === void 0 ? void 0 : _k[0];
        if (urlConfig) {
            if ("object" === typeof urlConfig) {
                if ("log" in urlConfig) {
                    if ("object" === typeof urlConfig["log"]) {
                        var urlConfigLog = urlConfig["log"];
                        if ("config" in urlConfigLog && "boolean" === typeof urlConfigLog["config"]) {
                            config.log.config = urlConfigLog["config"];
                        }
                        if ("load" in urlConfigLog && "boolean" === typeof urlConfigLog["load"]) {
                            config.log.load = urlConfigLog["load"];
                        }
                        if ("define" in urlConfigLog && "boolean" === typeof urlConfigLog["define"]) {
                            config.log.define = urlConfigLog["define"];
                        }
                        if ("results" in urlConfigLog && "boolean" === typeof urlConfigLog["results"]) {
                            config.log.results = urlConfigLog["results"];
                        }
                    }
                }
                if ("loadingTimeout" in urlConfig && "number" === typeof urlConfig["loadingTimeout"]) {
                    config.loadingTimeout = urlConfig["loadingTimeout"];
                }
            }
        }
    }
    catch (err) {
        console.error(err);
    }
    if (config.log.config) {
        console.log("evil-commonjs: evilCommonjsConfig: ".concat(JSON.stringify(config)));
    }
    gThis.require = function (path) {
        var _a;
        switch (path) {
            case "require":
                return window.require;
            case "exports":
                return evil.module.exports;
            default:
                var absolutePath = makeAbsoluteUrl(path);
                var result = (_a = evil.modules[absolutePath]) !== null && _a !== void 0 ? _a : evil.modules[path];
                if (!result) {
                    console.log("evil-commonjs: require(\"".concat(path, "\") -> \"").concat(absolutePath, "\""), getCurrentPath(), resolveMapping(path));
                    result = evil.modules[absolutePath] = {};
                    evil.unresolved.push(absolutePath);
                }
                return result;
        }
    };
    gThis.define = function (path, requires, content) {
        var absolutePath = makeAbsoluteUrl(path);
        if (evil.modules[absolutePath]) {
            if (config.log.define) {
                console.log("evil-commonjs: \"".concat(absolutePath, "\" is already defined!"));
            }
        }
        else {
            if (config.log.define) {
                console.log("evil-commonjs: define(\"".concat(absolutePath, "\", ").concat(JSON.stringify(requires), ", ...)"));
            }
            if (/\.json(\?.*)?$/i.test(path) || "function" !== typeof content) {
                return evil.modules[absolutePath] = content;
            }
            else {
                evil.module.readyToCapture(absolutePath);
                content.apply(null, requires.map(function (i) { return gThis.require(i); }));
                evil.module.capture(absolutePath);
            }
        }
    };
    setTimeout(function () {
        if (0 < evil.unresolved.length) {
            console.error("evil-commonjs: unresoled modules: ".concat(JSON.stringify(evil.unresolved)));
            // console.error(`"${path}" is not found! require() of evil-commonjs need to load() in advance.`);
            console.error("evil-commonjs: module mapping: ".concat(JSON.stringify(evil.mapping)));
            console.error("evil-commonjs: loaded modules: ".concat(JSON.stringify(Object.keys(evil.modules))));
            console.error(evil.modules);
        }
        else {
            if (config.log.results) {
                console.log("evil-commonjs: everything is OK!");
                console.log("evil-commonjs: module mapping: ".concat(JSON.stringify(evil.mapping)));
                console.log("evil-commonjs: loaded modules: ".concat(JSON.stringify(Object.keys(evil.modules))));
                console.log(evil.modules);
            }
        }
    }, config.loadingTimeout);
    window.module = evil.module;
})();
//# sourceMappingURL=evil-commonjs/index.js.map
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
define("evil-type.ts/common/evil-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EvilType = void 0;
    // Original: https://github.com/wraith13/evil-type.ts/blob/master/common/evil-type.ts
    // License: BSL-1.0 ( https://github.com/wraith13/evil-type.ts/blob/master/LICENSE_1_0.txt )
    var EvilType;
    (function (EvilType) {
        EvilType.comparer = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return function (a, b) {
                for (var i = 0; i < args.length; ++i) {
                    var focus_1 = args[i];
                    var af = focus_1(a);
                    var bf = focus_1(b);
                    if (af < bf) {
                        return -1;
                    }
                    if (bf < af) {
                        return 1;
                    }
                }
                return 0;
            };
        };
        EvilType.lazy = function (invoker) {
            return (function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return invoker().apply(void 0, args);
            });
        };
        var Error;
        (function (Error) {
            Error.makeListener = function (path) {
                if (path === void 0) { path = ""; }
                return ({
                    path: path,
                    matchRate: {},
                    errors: [],
                });
            };
            Error.nextListener = function (name, listner) {
                return (listner ?
                    {
                        path: Error.makePath(listner.path, name),
                        matchRate: listner.matchRate,
                        errors: listner.errors,
                    } :
                    undefined);
            };
            Error.makePath = function (path, name) {
                var base = path.includes("#") ? path : "".concat(path, "#");
                var separator = base.endsWith("#") || "string" !== typeof name ? "" : ".";
                var tail = "string" === typeof name ? name : "[".concat(name, "]");
                return base + separator + tail;
            };
            Error.getPathDepth = function (path) {
                var valuePath = path.replace(/[^#]*#/, "#").replace(/\[(\d+)\]/g, ".$1");
                return valuePath.split(/[#\.]/).filter(function (i) { return 0 < i.length; }).length;
            };
            Error.getType = function (isType) {
                var transactionListner = Error.makeListener();
                isType(undefined, transactionListner);
                return transactionListner.errors
                    .map(function (i) { return i.requiredType.split(" | "); })
                    .reduce(function (a, b) { return __spreadArray(__spreadArray([], a, true), b, true); }, [])
                    .filter(function (i, ix, list) { return ix === list.indexOf(i); });
            };
            Error.isMtached = function (matchRate) { return true === matchRate; };
            Error.matchRateToNumber = function (matchRate) {
                switch (matchRate) {
                    case false:
                        return 0;
                    case true:
                        return 1;
                    default:
                        return matchRate;
                }
            };
            Error.setMatchRate = function (listner, matchRate) {
                if (listner) {
                    listner.matchRate[listner.path] = matchRate;
                }
                return Error.isMtached(matchRate);
            };
            Error.getMatchRate = function (listner, path) {
                if (path === void 0) { path = listner.path; }
                if (path in listner.matchRate) {
                    return listner.matchRate[path];
                }
                return Error.calculateMatchRate(listner, path);
            };
            Error.calculateMatchRate = function (listner, path) {
                if (path === void 0) { path = listner.path; }
                var depth = Error.getPathDepth(path);
                var childrenKeys = Object.keys(listner.matchRate)
                    .filter(function (i) { return 0 === i.indexOf(path) && Error.getPathDepth(i) === depth + 1; });
                var length = childrenKeys.length;
                var sum = childrenKeys
                    .map(function (i) { return listner.matchRate[i]; })
                    .map(function (i) { return Error.matchRateToNumber(i); })
                    .reduce(function (a, b) { return a + b; }, 0.0);
                var result = 0 < length ? sum / length : true;
                if (true === result || 1.0 <= result) {
                    console.error("ðŸ¦‹ FIXME: \"MatchWithErrors\": " + JSON.stringify({ sum: sum, length: length, result: result, listner: listner }));
                }
                return listner.matchRate[path] = result;
            };
            Error.setMatch = function (listner) {
                if (listner) {
                    var paths = Object.keys(listner.matchRate)
                        .filter(function (path) { return 0 === path.indexOf(listner.path); });
                    if (paths.every(function (path) { return Error.isMtached(listner.matchRate[path]); })) {
                        paths.forEach(function (path) { return delete listner.matchRate[path]; });
                    }
                }
                Error.setMatchRate(listner, true);
            };
            Error.raiseError = function (listner, requiredType, actualValue) {
                if (listner) {
                    Error.setMatchRate(listner, false);
                    listner.errors.push({
                        type: "solid",
                        path: listner.path,
                        requiredType: "string" === typeof requiredType ? requiredType : requiredType(),
                        actualValue: Error.valueToString(actualValue),
                    });
                }
                return false;
            };
            Error.orErros = function (listner, modulus, errors, fullErrors) {
                var _a;
                var paths = errors.map(function (i) { return i.path; }).filter(function (i, ix, list) { return ix === list.indexOf(i); });
                (_a = listner.errors).push.apply(_a, paths.map(function (path) {
                    return ({
                        type: modulus <= fullErrors.filter(function (i) { return "solid" === i.type && i.path === path; }).length ?
                            "solid" :
                            "fragment",
                        path: path,
                        requiredType: errors
                            .filter(function (i) { return i.path === path; })
                            .map(function (i) { return i.requiredType; })
                            .map(function (i) { return i.split(" | "); })
                            .reduce(function (a, b) { return __spreadArray(__spreadArray([], a, true), b, true); }, [])
                            .filter(function (i, ix, list) { return ix === list.indexOf(i); })
                            .join(" | "),
                        actualValue: errors.filter(function (i) { return i.path === path; }).map(function (i) { return i.actualValue; })[0],
                    });
                }));
            };
            Error.andErros = function (listner, errors) {
                var _a;
                var paths = errors.map(function (i) { return i.path; }).filter(function (i, ix, list) { return ix === list.indexOf(i); });
                (_a = listner.errors).push.apply(_a, paths.map(function (path) {
                    return ({
                        type: errors.some(function (i) { return "solid" === i.type && i.path === path; }) ?
                            "solid" :
                            "fragment",
                        path: path,
                        requiredType: errors
                            .filter(function (i) { return i.path === path; })
                            .map(function (i) { return i.requiredType; })
                            .map(function (i) { return i.split(" & "); })
                            .reduce(function (a, b) { return __spreadArray(__spreadArray([], a, true), b, true); }, [])
                            .filter(function (i, ix, list) { return ix === list.indexOf(i); })
                            .join(" & "),
                        actualValue: errors.filter(function (i) { return i.path === path; }).map(function (i) { return i.actualValue; })[0],
                    });
                }));
            };
            Error.valueToString = function (value) {
                return undefined === value ? "undefined" : JSON.stringify(value);
            };
            Error.withErrorHandling = function (isMatchType, listner, requiredType, actualValue) {
                if (listner) {
                    if (isMatchType) {
                        Error.setMatch(listner);
                    }
                    else {
                        Error.raiseError(listner, requiredType, actualValue);
                    }
                }
                return isMatchType;
            };
        })(Error = EvilType.Error || (EvilType.Error = {}));
        var Validator;
        (function (Validator) {
            Validator.makeErrorListener = Error.makeListener;
            Validator.isJust = function (target) { return null !== target && "object" === typeof target ?
                function (value, listner) {
                    return Error.withErrorHandling(JSON.stringify(target) === JSON.stringify(value), listner, function () { return Error.valueToString(target); }, value);
                } :
                function (value, listner) {
                    return Error.withErrorHandling(target === value, listner, function () { return Error.valueToString(target); }, value);
                }; };
            Validator.isNever = function (value, listner) {
                return Error.withErrorHandling(false, listner, "never", value);
            };
            Validator.isUndefined = Validator.isJust(undefined);
            Validator.isUnknown = function (_value, _listner) { return true; };
            Validator.isAny = function (_value, _listner) { return true; };
            Validator.isNull = Validator.isJust(null);
            Validator.isBoolean = function (value, listner) {
                return Error.withErrorHandling("boolean" === typeof value, listner, "boolean", value);
            };
            Validator.isInteger = function (value, listner) {
                return Error.withErrorHandling(Number.isInteger(value), listner, "integer", value);
            };
            Validator.isSafeInteger = function (value, listner) {
                return Error.withErrorHandling(Number.isSafeInteger(value), listner, "safe-integer", value);
            };
            Validator.isDetailedInteger = function (data, safeInteger) {
                var base = "safe" === safeInteger ? Validator.isSafeInteger : Validator.isInteger;
                if ([data.minimum, data.exclusiveMinimum, data.maximum, data.exclusiveMaximum, data.multipleOf].every(function (i) { return undefined === i; })) {
                    return base;
                }
                else {
                    var result = function (value, listner) { return Error.withErrorHandling(base(value) &&
                        (undefined === data.minimum || data.minimum <= value) &&
                        (undefined === data.exclusiveMinimum || data.exclusiveMinimum < value) &&
                        (undefined === data.maximum || value <= data.maximum) &&
                        (undefined === data.exclusiveMaximum || value < data.exclusiveMaximum) &&
                        (undefined === data.multipleOf || 0 === value % data.multipleOf), listner, function () {
                        var details = [];
                        if (undefined !== data.minimum) {
                            details.push("minimum:".concat(data.minimum));
                        }
                        if (undefined !== data.exclusiveMinimum) {
                            details.push("exclusiveMinimum:".concat(data.exclusiveMinimum));
                        }
                        if (undefined !== data.maximum) {
                            details.push("maximum:".concat(data.maximum));
                        }
                        if (undefined !== data.exclusiveMaximum) {
                            details.push("exclusiveMaximum:".concat(data.exclusiveMaximum));
                        }
                        if (undefined !== data.multipleOf) {
                            details.push("multipleOf:".concat(data.multipleOf));
                        }
                        return "".concat("safe" === safeInteger ? "safe-integer" : "integer", "(").concat(details.join(","), ")");
                    }, value); };
                    return result;
                }
            };
            Validator.isNumber = function (value, listner) {
                return Error.withErrorHandling("number" === typeof value, listner, "number", value);
            };
            Validator.isSafeNumber = function (value, listner) {
                return Error.withErrorHandling(Number.isFinite(value), listner, "safe-number", value);
            };
            Validator.isDetailedNumber = function (data, safeNumber) {
                var base = "safe" === safeNumber ? Validator.isSafeNumber : Validator.isNumber;
                if ([data.minimum, data.exclusiveMinimum, data.maximum, data.exclusiveMaximum, data.multipleOf].every(function (i) { return undefined === i; })) {
                    return base;
                }
                else {
                    var result = function (value, listner) { return Error.withErrorHandling(base(value) &&
                        (undefined === data.minimum || data.minimum <= value) &&
                        (undefined === data.exclusiveMinimum || data.exclusiveMinimum < value) &&
                        (undefined === data.maximum || value <= data.maximum) &&
                        (undefined === data.exclusiveMaximum || value < data.exclusiveMaximum) &&
                        (undefined === data.multipleOf || 0 === value % data.multipleOf), listner, function () {
                        var details = [];
                        if (undefined !== data.minimum) {
                            details.push("minimum:".concat(data.minimum));
                        }
                        if (undefined !== data.exclusiveMinimum) {
                            details.push("exclusiveMinimum:".concat(data.exclusiveMinimum));
                        }
                        if (undefined !== data.maximum) {
                            details.push("maximum:".concat(data.maximum));
                        }
                        if (undefined !== data.exclusiveMaximum) {
                            details.push("exclusiveMaximum:".concat(data.exclusiveMaximum));
                        }
                        if (undefined !== data.multipleOf) {
                            details.push("multipleOf:".concat(data.multipleOf));
                        }
                        return "".concat("safe" === safeNumber ? "safe-number" : "number", "(").concat(details.join(","), ")");
                    }, value); };
                    return result;
                }
            };
            Validator.isString = function (value, listner) {
                return Error.withErrorHandling("string" === typeof value, listner, "string", value);
            };
            Validator.makeStringTypeName = function (data) {
                var details = [];
                if (undefined !== data.minLength) {
                    details.push("minLength:".concat(data.minLength));
                }
                if (undefined !== data.maxLength) {
                    details.push("maxLength:".concat(data.maxLength));
                }
                if (undefined !== data.format) {
                    details.push("format:".concat(data.format));
                }
                else if (undefined !== data.pattern) {
                    details.push("pattern:".concat(data.pattern));
                }
                if (undefined !== data.regexpFlags) {
                    details.push("regexpFlags:".concat(data.regexpFlags));
                }
                return "string(".concat(details.join(","), ")");
            };
            Validator.regexpTest = function (pattern, flags, text) {
                switch (pattern) {
                    case "^[[:regex:]]$":
                        try {
                            new RegExp(text, flags);
                            return true;
                        }
                        catch (_a) {
                            return false;
                        }
                    default:
                        return new RegExp(pattern, flags).test(text);
                }
            };
            Validator.isDetailedString = function (data, regexpFlags) {
                if ([data.minLength, data.maxLength, data.pattern, data.format].every(function (i) { return undefined === i; })) {
                    return Validator.isString;
                }
                var pattern = data.pattern;
                var result = function (value, listner) {
                    var _a, _b, _c;
                    return Error.withErrorHandling("string" === typeof value &&
                        (undefined === data.minLength || data.minLength <= value.length) &&
                        (undefined === data.maxLength || value.length <= data.maxLength) &&
                        (undefined === pattern || ((_a = data.regexpTest) !== null && _a !== void 0 ? _a : Validator.regexpTest)(pattern, (_c = (_b = data.regexpFlags) !== null && _b !== void 0 ? _b : regexpFlags) !== null && _c !== void 0 ? _c : "u", value)), listner, function () { return Validator.makeStringTypeName(data); }, value);
                };
                return result;
            };
            Validator.isObject = function (value) {
                return null !== value && "object" === typeof value && !Array.isArray(value);
            };
            Validator.isEnum = function (list) {
                return function (value, listner) {
                    return Error.withErrorHandling(list.includes(value), listner, function () { return list.map(function (i) { return Error.valueToString(i); }).join(" | "); }, value);
                };
            };
            Validator.isUniqueItems = function (list) {
                return list.map(function (i) { return JSON.stringify(i); }).every(function (i, ix, list) { return ix === list.indexOf(i); });
            };
            Validator.makeArrayTypeName = function (data) {
                var details = [];
                if (undefined !== (data === null || data === void 0 ? void 0 : data.minItems)) {
                    details.push("minItems:".concat(data.minItems));
                }
                if (undefined !== (data === null || data === void 0 ? void 0 : data.maxItems)) {
                    details.push("maxItems:".concat(data.maxItems));
                }
                if (true === (data === null || data === void 0 ? void 0 : data.uniqueItems)) {
                    details.push("uniqueItems:".concat(data.uniqueItems));
                }
                return details.length <= 0 ? "array" : "array(".concat(details.join(","), ")");
            };
            Validator.isArray = function (isType, data) {
                return function (value, listner) {
                    if (Array.isArray(value) &&
                        (undefined === (data === null || data === void 0 ? void 0 : data.minItems) || data.minItems <= value.length) &&
                        (undefined === (data === null || data === void 0 ? void 0 : data.maxItems) || value.length <= data.maxItems) &&
                        (true !== (data === null || data === void 0 ? void 0 : data.uniqueItems) || Validator.isUniqueItems(value))) {
                        var result = value.map(function (i) { return isType(i, listner); }).every(function (i) { return i; });
                        if (listner) {
                            if (result) {
                                Error.setMatch(listner);
                            }
                            else {
                                Error.calculateMatchRate(listner);
                            }
                        }
                        return result;
                    }
                    else {
                        return undefined !== listner && Error.raiseError(listner, function () { return Validator.makeArrayTypeName(data); }, value);
                    }
                };
            };
            Validator.makeOrTypeNameFromIsTypeList = function () {
                var isTypeList = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    isTypeList[_i] = arguments[_i];
                }
                return isTypeList.map(function (i) { return Error.getType(i); })
                    .reduce(function (a, b) { return __spreadArray(__spreadArray([], a, true), b, true); }, [])
                    .filter(function (i, ix, list) { return ix === list.indexOf(i); });
            };
            Validator.getBestMatchErrors = function (listeners) {
                return listeners.map(function (listener) {
                    return ({
                        listener: listener,
                        matchRate: Error.getMatchRate(listener),
                    });
                })
                    .sort(EvilType.comparer(function (i) { return -Error.matchRateToNumber(i.matchRate); }))
                    .filter(function (i, _ix, list) { return i.matchRate === list[0].matchRate; })
                    .map(function (i) { return i.listener; });
            };
            Validator.isOr = function () {
                var isTypeList = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    isTypeList[_i] = arguments[_i];
                }
                return function (value, listner) {
                    if (listner) {
                        var resultList = isTypeList.map(function (i) {
                            var transactionListner = Error.makeListener(listner.path);
                            var result = {
                                transactionListner: transactionListner,
                                result: i(value, transactionListner),
                            };
                            return result;
                        });
                        var success = resultList.filter(function (i) { return i.result; })[0];
                        var result = Boolean(success);
                        if (result) {
                            Error.setMatch(listner);
                        }
                        else {
                            var requiredType = Validator.makeOrTypeNameFromIsTypeList.apply(void 0, isTypeList);
                            if ((Validator.isObject(value) && requiredType.includes("object")) || (Array.isArray(value) && requiredType.includes("array"))) {
                                var bestMatchErrors = Validator.getBestMatchErrors(resultList.map(function (i) { return i.transactionListner; }));
                                var errors = bestMatchErrors.map(function (i) { return i.errors; }).reduce(function (a, b) { return __spreadArray(__spreadArray([], a, true), b, true); }, []);
                                var fullErrors = resultList.map(function (i) { return i.transactionListner; }).map(function (i) { return i.errors; }).reduce(function (a, b) { return __spreadArray(__spreadArray([], a, true), b, true); }, []);
                                Error.orErros(listner, isTypeList.length, errors, fullErrors);
                                if (errors.length <= 0) {
                                    console.error("ðŸ¦‹ FIXME: \"UnmatchWithoutErrors\": " + JSON.stringify(resultList));
                                }
                                if (0 < bestMatchErrors.length) {
                                    Object.entries(bestMatchErrors[0].matchRate).forEach(function (kv) { return listner.matchRate[kv[0]] = kv[1]; });
                                }
                            }
                            else {
                                Error.raiseError(listner, requiredType.join(" | "), value);
                            }
                        }
                        return result;
                    }
                    else {
                        return isTypeList.some(function (i) { return i(value); });
                    }
                };
            };
            Validator.isAnd = function () {
                var isTypeList = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    isTypeList[_i] = arguments[_i];
                }
                return function (value, listner) {
                    if (listner) {
                        var resultList = isTypeList.map(function (i) {
                            var transactionListner = Error.makeListener(listner.path);
                            var result = {
                                transactionListner: transactionListner,
                                result: i(value, transactionListner),
                            };
                            return result;
                        });
                        var result = resultList.every(function (i) { return i.result; });
                        if (result) {
                            Error.setMatch(listner);
                        }
                        else {
                            var requiredType = Validator.makeOrTypeNameFromIsTypeList.apply(void 0, isTypeList);
                            if ((Validator.isObject(value) && requiredType.includes("object")) || (Array.isArray(value) && requiredType.includes("array"))) {
                                var transactionListners_1 = resultList.map(function (i) { return i.transactionListner; });
                                var errors = transactionListners_1.map(function (i) { return i.errors; }).reduce(function (a, b) { return __spreadArray(__spreadArray([], a, true), b, true); }, []);
                                Error.andErros(listner, errors);
                                if (errors.length <= 0) {
                                    console.error("ðŸ¦‹ FIXME: \"UnmatchWithoutErrors\": " + JSON.stringify(resultList));
                                }
                                if (0 < transactionListners_1.length) {
                                    var paths = transactionListners_1
                                        .map(function (i) { return Object.keys(i.matchRate); })
                                        .reduce(function (a, b) { return __spreadArray(__spreadArray([], a, true), b, true); }, [])
                                        .filter(function (i, ix, list) { return ix === list.indexOf(i); });
                                    paths.forEach(function (path) {
                                        var matchRates = transactionListners_1.map(function (i) { return i.matchRate[path]; })
                                            .filter(function (i) { return undefined !== i; });
                                        if (matchRates.every(function (i) { return true === i; })) {
                                            listner.matchRate[path] = true;
                                        }
                                        else {
                                            listner.matchRate[path] = matchRates
                                                .map(function (i) { return Error.matchRateToNumber(i); })
                                                .reduce(function (a, b) { return a + b; }, 0)
                                                / matchRates.length;
                                        }
                                    });
                                }
                            }
                            else {
                                Error.raiseError(listner, requiredType.join(" & "), value);
                            }
                        }
                        return result;
                    }
                    else {
                        return isTypeList.some(function (i) { return i(value); });
                    }
                };
            };
            Validator.isNeverTypeGuard = function (value, listner) {
                return Validator.isSpecificObject({
                    $type: Validator.isJust("never-type-guard"),
                })(value, listner);
            };
            Validator.isNeverMemberType = function (value, member, _neverTypeGuard, listner) {
                return !(member in value) || Validator.isNever(value[member], listner);
            };
            Validator.isOptionalTypeGuard = function (value, listner) {
                return Validator.isSpecificObject({
                    $type: Validator.isJust("optional-type-guard"),
                    isType: function (value, listner) {
                        return "function" === typeof value || (null !== value && "object" === typeof value) || (undefined !== listner && Error.raiseError(listner, "IsType<unknown> | ObjectValidator<unknown>", value));
                    },
                })(value, listner);
            };
            Validator.makeOptionalTypeGuard = function (isType) {
                return ({
                    $type: "optional-type-guard",
                    isType: isType,
                });
            };
            Validator.invokeIsType = function (isType) {
                return "function" === typeof isType ? isType : Validator.isSpecificObject(isType);
            };
            Validator.isOptional = Validator.makeOptionalTypeGuard;
            Validator.isOptionalMemberType = function (value, member, optionalTypeGuard, listner) {
                var result = !(member in value) || Validator.invokeIsType(optionalTypeGuard.isType)(value[member], listner);
                if (!result && listner) {
                    var error = listner.errors.filter(function (i) { return i.path === listner.path; })[0];
                    if (error) {
                        error.requiredType = "never | " + error.requiredType;
                    }
                    else {
                        // Not wrong, but noisy!
                        // listner.errors.filter(i => 0 === i.path.indexOf(listner.path) && "fragment" !== i.type).forEach(i => i.type = "fragment");
                        // listner.errors.push
                        // ({
                        //     type: "fragment",
                        //     path: listner.path,
                        //     requiredType: "never",
                        //     actualValue: Error.valueToString((value as ObjectType)[member]),
                        // });
                    }
                }
                return result;
            };
            Validator.isMemberType = function (value, member, isType, listner) {
                return Validator.isNeverTypeGuard(isType) ?
                    Validator.isNeverMemberType(value, member, isType, listner) :
                    Validator.isOptionalTypeGuard(isType) ?
                        Validator.isOptionalMemberType(value, member, isType, listner) :
                        Validator.invokeIsType(isType)(value[member], listner);
            };
            Validator.mergeObjectValidator = function (target) {
                var sources = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    sources[_i - 1] = arguments[_i];
                }
                return Object.assign.apply(Object, __spreadArray([{}, target], sources, true));
            };
            Validator.isSpecificObject = function (memberValidator, options) {
                return function (value, listner) {
                    if (Validator.isObject(value)) {
                        var result = Object.entries("function" === typeof memberValidator ? memberValidator() : memberValidator).map(function (kv) { return Validator.isMemberType(value, kv[0], kv[1], Error.nextListener(kv[0], listner)); })
                            .every(function (i) { return i; });
                        if (false === (options === null || options === void 0 ? void 0 : options.additionalProperties)) {
                            var regularKeys_1 = Object.keys(memberValidator);
                            var additionalKeys = Object.keys(value)
                                .filter(function (key) { return !regularKeys_1.includes(key); });
                            if (additionalKeys.some(function (_) { return true; })) {
                                additionalKeys.map(function (key) { return Error.raiseError(Error.nextListener(key, listner), "never", value[key]); });
                                result = false;
                            }
                        }
                        if (listner) {
                            if (result) {
                                Error.setMatch(listner);
                            }
                            else {
                                Error.calculateMatchRate(listner);
                            }
                        }
                        return result;
                    }
                    else {
                        return undefined !== listner && Error.raiseError(listner, "object", value);
                    }
                };
            };
            Validator.isDictionaryObject = function (isType, keys, options) {
                return function (value, listner) {
                    if (Validator.isObject(value)) {
                        var result = undefined === keys ?
                            Object.entries(value).map(function (kv) { return isType(kv[1], Error.nextListener(kv[0], listner)); }).every(function (i) { return i; }) :
                            keys.map(function (key) { return isType(value, Error.nextListener(key, listner)); }).every(function (i) { return i; });
                        if (undefined !== keys && false === (options === null || options === void 0 ? void 0 : options.additionalProperties)) {
                            var additionalKeys = Object.keys(value)
                                .filter(function (key) { return !keys.includes(key); });
                            if (additionalKeys.some(function (_) { return true; })) {
                                additionalKeys.map(function (key) { return Error.raiseError(Error.nextListener(key, listner), "never", value[key]); });
                                result = false;
                            }
                        }
                        if (listner) {
                            if (result) {
                                Error.setMatch(listner);
                            }
                            else {
                                Error.calculateMatchRate(listner);
                            }
                        }
                        return result;
                    }
                    else {
                        return undefined !== listner && Error.raiseError(listner, "object", value);
                    }
                };
            };
        })(Validator = EvilType.Validator || (EvilType.Validator = {}));
    })(EvilType || (exports.EvilType = EvilType = {}));
});
define("generated/type", ["require", "exports", "evil-type.ts/common/evil-type"], function (require, exports, evil_type_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Type = exports.EvilType = void 0;
    Object.defineProperty(exports, "EvilType", { enumerable: true, get: function () { return evil_type_1.EvilType; } });
    var Type;
    (function (Type) {
        Type.isStyleReplaceModeType = evil_type_1.EvilType.Validator.isEnum(["auto", "disabled",
            "embedded", "rules"]);
        Type.isEvilTimerConfigType = evil_type_1.EvilType.lazy(function () { return evil_type_1.EvilType.Validator.isSpecificObject(Type.evilTimerConfigTypeValidatorObject, {
            additionalProperties: false
        }); });
        Type.evilTimerConfigTypeValidatorObject = ({ $schema: evil_type_1.EvilType.Validator.isOptional(evil_type_1.EvilType.Validator.isJust("https://raw.githubusercontent.com/wraith13/evil-timer.js/master/generated/schema.json#")), disabled: evil_type_1.EvilType.Validator.isOptional(evil_type_1.EvilType.Validator.isBoolean), debug: evil_type_1.EvilType.Validator.isOptional(evil_type_1.EvilType.Validator.isBoolean),
            disabledLoadMessage: evil_type_1.EvilType.Validator.isOptional(evil_type_1.EvilType.Validator.isBoolean), date: evil_type_1.EvilType.Validator.isOptional(evil_type_1.EvilType.Validator.isOr(evil_type_1.EvilType.Validator.isBoolean, evil_type_1.EvilType.Validator.isNumber, evil_type_1.EvilType.Validator.isString)), speed: evil_type_1.EvilType.Validator.isOptional(evil_type_1.EvilType.Validator.isNumber), pause: evil_type_1.EvilType.Validator.isOptional(evil_type_1.EvilType.Validator.isBoolean),
            styleReplaceMode: evil_type_1.EvilType.Validator.isOptional(Type.isStyleReplaceModeType), });
    })(Type || (exports.Type = Type = {}));
});
define("index", ["require", "exports", "generated/type"], function (require, exports, type_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EvilTimer = void 0;
    var EvilTimer;
    (function (EvilTimer) {
        var _a, _b, _c, _d;
        EvilTimer.Type = type_1.Type;
        var gThis = ((_a = self !== null && self !== void 0 ? self : window) !== null && _a !== void 0 ? _a : global);
        var VanillaDate = Date;
        var vanillaSetTimeout = setTimeout;
        var vanillaSetInteral = setInterval;
        var vanillaRequestAnimationFrame = (window !== null && window !== void 0 ? window : {}).requestAnimationFrame;
        var dateMode = "evil";
        EvilTimer.setDateMode = function (mode) {
            switch (mode) {
                case "vanilla":
                case "evil":
                    dateMode = mode;
                    break;
                default:
                    console.error("setDateMode(".concat(JSON.stringify(mode), " as \"vanilla\" | \"evil\");"));
                    break;
            }
        };
        var styleReplaceMode = "disabled";
        var originalEmbeddedStyles = null;
        var originalStyleRules = null;
        // let originalStyleSheets:string[] = null;
        var speed = 1;
        var isRegularSpeed = function () { return 1 === speed; };
        var isPaused = false;
        var susppendedTasks = [];
        var ankerAt = {
            vanilla: 0,
            evil: 0,
            vanillaPerformance: 0,
            evilPerformance: 0,
        };
        EvilTimer.getVanillaNow = function () { return new VanillaDate().getTime(); };
        EvilTimer.getEvilNow = function () {
            return !isAnkered() ?
                EvilTimer.getVanillaNow() :
                ankerAt.evil + (isPaused ? 0 : (speed * (EvilTimer.getVanillaNow() - ankerAt.vanilla)));
        };
        EvilTimer.getVanillaPerformanceNow = function () { return performance.now(); };
        EvilTimer.getEvilPerformanceNow = function () {
            return !isAnkered() ?
                EvilTimer.getVanillaPerformanceNow() :
                ankerAt.evilPerformance + (isPaused ? 0 : (speed * (EvilTimer.getVanillaPerformanceNow() - ankerAt.vanillaPerformance)));
        };
        var isAnkered = function () { return 0 !== ankerAt.vanilla; };
        var setAnkerAt = function (evil, evilPerformance) { return ankerAt =
            {
                vanilla: EvilTimer.getVanillaNow(),
                evil: evil !== null && evil !== void 0 ? evil : EvilTimer.getEvilNow(),
                vanillaPerformance: EvilTimer.getVanillaPerformanceNow(),
                evilPerformance: evilPerformance !== null && evilPerformance !== void 0 ? evilPerformance : EvilTimer.getEvilPerformanceNow(),
            }; };
        var resetAnkerAt = function (vanilla, vanillaPerformance) {
            if (vanilla === void 0) { vanilla = isRegularSpeed() ? 0 : EvilTimer.getVanillaNow(); }
            if (vanillaPerformance === void 0) { vanillaPerformance = isRegularSpeed() ? 0 : EvilTimer.getVanillaPerformanceNow(); }
            return ankerAt =
                {
                    vanilla: vanilla,
                    evil: vanilla,
                    vanillaPerformance: vanillaPerformance,
                    evilPerformance: vanillaPerformance,
                };
        };
        /*
        remain for support to timezone and locale.
        class EvilDateBody
        {
            vanilla: Date;
            constructor();
            constructor(value: number | string);
            constructor(year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number);
            constructor(year?: number | string, month?: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number)
            {
                if (undefined !== year)
                {
                    if ("number" === typeof year && undefined !== month)
                    {
                        this.vanilla = new VanillaDate(year, month, date, hours, minutes, seconds, ms);
                    }
                    else
                    {
                        this.vanilla = new VanillaDate(year);
                    }
                }
                else
                {
                    this.vanilla = new VanillaDate(getEvilNow());
                }
            }
            toString = () => this.vanilla.toString();
            toDateString = () => this.vanilla.toDateString();
            toTimeString = () => this.vanilla.toTimeString();
            toLocaleString = () => this.vanilla.toLocaleString();
            toLocaleDateString = () => this.vanilla.toLocaleDateString();
            toLocaleTimeString = () => this.vanilla.toLocaleTimeString();
            valueOf = () => this.vanilla.valueOf();
            getTime = () => this.vanilla.getTime();
            getFullYear = () => this.vanilla.getFullYear();
            getUTCFullYear = () => this.vanilla.getUTCFullYear();
            getMonth = () => this.vanilla.getMonth();
            getUTCMonth = () => this.vanilla.getUTCMonth();
            getDate = () => this.vanilla.getDate();
            getUTCDate = () => this.vanilla.getUTCDate();
            getDay = () => this.vanilla.getDay();
            getUTCDay = () => this.vanilla.getUTCDay();
            getHours = () => this.vanilla.getHours();
            getUTCHours = () => this.vanilla.getUTCHours();
            getMinutes = () => this.vanilla.getMinutes();
            getUTCMinutes = () => this.vanilla.getUTCMinutes();
            getSeconds = () => this.vanilla.getSeconds();
            getUTCSeconds = () => this.vanilla.getUTCSeconds();
            getMilliseconds = () => this.vanilla.getMilliseconds();
            getUTCMilliseconds = () => this.vanilla.getUTCMilliseconds();
            getTimezoneOffset = () => this.vanilla.getTimezoneOffset();
            setTime = (time: number) => this.vanilla.setTime(time);
            setMilliseconds = (ms: number) => this.vanilla.setMilliseconds(ms);
            setUTCMilliseconds = (ms: number) => this.vanilla.setUTCMilliseconds(ms);
            setSeconds = (sec: number, ms?: number) => this.vanilla.setSeconds(sec, ms);
            setUTCSeconds = (sec: number, ms?: number) => this.vanilla.setUTCSeconds(sec, ms);
            setMinutes = (min: number, sec?: number, ms?: number) => this.vanilla.setMinutes(min, sec, ms);
            setUTCMinutes = (min: number, sec?: number, ms?: number) => this.vanilla.setUTCMinutes(min, sec, ms);
            setHours = (hours: number, min?: number, sec?: number, ms?: number) => this.vanilla.setHours(hours, min, sec, ms);
            setUTCHours = (hours: number, min?: number, sec?: number, ms?: number) => this.vanilla.setUTCHours(hours, min, sec, ms);
            setDate = (date: number) => this.vanilla.setDate(date);
            setUTCDate = (date: number) => this.vanilla.setUTCDate(date);
            setMonth = (month: number, date?: number) => this.vanilla.setMonth(month, date);
            setUTCMonth = (month: number, date?: number) => this.vanilla.setUTCMonth(month, date);
            setFullYear = (year: number, month?: number, date?: number) => this.vanilla.setFullYear(year, month, date);
            setUTCFullYear = (year: number, month?: number, date?: number) => this.vanilla.setUTCFullYear(year, month, date);
            toUTCString = () => this.vanilla.toUTCString();
            toISOString = () => this.vanilla.toISOString();
            toJSON = (key?: any) => this.vanilla.toJSON(key);
            static parse = (s: string) => VanillaDate.parse(s);
            static UTC = (year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number) => VanillaDate.UTC(year, month, date, hours, minutes, seconds, ms);
            static now = () => new EvilDateBody().getTime();
        }
        */
        EvilTimer.EvilDate = function _e() {
            var _newTarget = this && this instanceof _e ? this.constructor : void 0;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if ("evil" === dateMode && isAnkered() && 0 === args.length) {
                return _newTarget ?
                    new VanillaDate(EvilTimer.getEvilNow()) :
                    new VanillaDate(EvilTimer.getEvilNow()).toString();
            }
            else {
                return _newTarget ? new (VanillaDate.bind.apply(VanillaDate, __spreadArray([void 0], args, false)))() : VanillaDate.apply(void 0, args);
            }
        };
        EvilTimer.EvilDate.parse = VanillaDate.parse;
        EvilTimer.EvilDate.UTC = VanillaDate.UTC;
        EvilTimer.EvilDate.now = EvilTimer.getEvilNow;
        EvilTimer.setDate = function (date) {
            if ("boolean" === typeof date) {
                EvilTimer.setDateMode(date ? "evil" : "vanilla");
            }
            else {
                EvilTimer.setDateMode("evil");
                setAnkerAt("number" === typeof date ? date :
                    "string" === typeof date ? VanillaDate.parse(date) :
                        date.getTime());
            }
        };
        EvilTimer.resetDate = function () { return resetAnkerAt(); };
        EvilTimer.restore = function () {
            EvilTimer.setSpeed(1);
            EvilTimer.unpause();
            resetAnkerAt();
        };
        EvilTimer.pause = function () {
            setAnkerAt();
            isPaused = true;
        };
        EvilTimer.unpause = function () {
            setAnkerAt();
            isPaused = false;
            EvilTimer.stepOut();
        };
        EvilTimer.step = function (count) {
            var _a;
            if (count === void 0) { count = 1; }
            for (var i = 0; i < count; ++i) {
                (_a = susppendedTasks.shift()) === null || _a === void 0 ? void 0 : _a();
            }
            return susppendedTasks.length;
        };
        EvilTimer.stepAll = function () {
            EvilTimer.step(susppendedTasks.length);
        };
        EvilTimer.stepOut = function () {
            while (0 < EvilTimer.step())
                ;
        };
        var styleTimerRegExp = /((?:animation|transition)(?:-duration|-delay)?\s*:)([\+\-0-9A-Za-z.\s]+);/gm;
        var hasTimer = function (css) { return styleTimerRegExp.test(css); };
        var replaceTimer = function (rate, css) { return css.replace(styleTimerRegExp, function (_m, p1, p2) { return "".concat(p1).concat(p2.replace(/([\+\-]?[0-9.]+)(m?s)/gm, function (_m, p1, p2) { return (parseFloat(p1) / Math.abs(rate)).toLocaleString("en") + p2; }), ";"); }); };
        var updateEmbeddedStyle = function (rate) {
            if (rate === void 0) { rate = speed; }
            var styles = Array.from(document.getElementsByTagName("style"));
            if (null === originalEmbeddedStyles) {
                originalEmbeddedStyles = styles.map(function (i) { return i.innerHTML; });
            }
            styles.forEach(function (i, ix) {
                var _a, _b;
                if (hasTimer((_a = originalEmbeddedStyles === null || originalEmbeddedStyles === void 0 ? void 0 : originalEmbeddedStyles[ix]) !== null && _a !== void 0 ? _a : "")) {
                    i.innerHTML = replaceTimer(rate, (_b = originalEmbeddedStyles === null || originalEmbeddedStyles === void 0 ? void 0 : originalEmbeddedStyles[ix]) !== null && _b !== void 0 ? _b : "");
                }
            });
        };
        var updateStyleRules = function (rate) {
            if (rate === void 0) { rate = speed; }
            var styles = Array.from(document.styleSheets);
            if (null === originalStyleRules) {
                originalStyleRules = styles.map(function (stylesheet) {
                    try {
                        var rules = Array.from(stylesheet.cssRules).map(function (rule) { return rule.cssText; });
                        if (0 < rules.filter(function (rule) { return hasTimer(rule !== null && rule !== void 0 ? rule : ""); }).length) {
                            return rules;
                        }
                    }
                    catch (_a) {
                        console.error("Can not read: ".concat(stylesheet.href));
                    }
                    return null;
                });
            }
            styles.forEach(function (stylesheet, ix) {
                var _a;
                if (null !== (originalStyleRules === null || originalStyleRules === void 0 ? void 0 : originalStyleRules[ix])) {
                    while (0 < stylesheet.cssRules.length) {
                        stylesheet.deleteRule(0);
                    }
                    (_a = originalStyleRules === null || originalStyleRules === void 0 ? void 0 : originalStyleRules[ix]) === null || _a === void 0 ? void 0 : _a.forEach(function (rule) { return stylesheet.insertRule(replaceTimer(rate, rule)); });
                }
            });
        };
        // const updateStyleSheets = () =>
        // {
        //     const styles = <CSSStyleSheet[]>Array.from(document.styleSheets);
        //     if (null === originalStyleSheets)
        //     {
        //         originalStyleSheets = styles.map
        //         (
        //             stylesheet =>
        //             {
        //                 try
        //                 {
        //                     const rules = Array.from(stylesheet.cssRules).map(rule => rule.cssText).join(" ");
        //                     if (0 <= rules.indexOf("animation-duration"))
        //                     {
        //                         return rules;
        //                     }
        //                 }
        //                 catch
        //                 {
        //                     console.error(`Can not read: ${stylesheet.href}`);
        //                 }
        //                 return null;
        //             }
        //         );
        //     }
        //     styles.forEach
        //     (
        //         (stylesheet, ix) =>
        //         {
        //             if (null !== originalStyleSheets[ix])
        //             {
        //                 (<any>stylesheet).replaceSync(replaceAnimationDuration(originalStyleSheets[ix]));
        //             }
        //         }
        //     );
        // };
        // const isChromium = () => !! (<any>window).chrome;
        var isEmbeddedStyleOnly = function () {
            return Array.from(document.getElementsByTagName("link"))
                .filter(function (i) { return "stylesheet" === i.rel; }).length <= 0;
        };
        EvilTimer.getStyleReplaceMode = function () {
            switch (styleReplaceMode) {
                case "auto":
                    // if (isChromium())
                    // {
                    //     return "sheets";
                    // }
                    if (isEmbeddedStyleOnly()) {
                        return "embedded";
                    }
                    return "rules";
                default:
                    return styleReplaceMode;
            }
        };
        var updateStyle = function (rate) {
            if (rate === void 0) { rate = speed; }
            switch (EvilTimer.getStyleReplaceMode()) {
                case "embedded":
                    updateEmbeddedStyle(rate);
                    break;
                case "rules":
                    updateStyleRules(rate);
                    break;
                // case "sheets":
                //     updateStyleSheets();
                //     break;
            }
        };
        EvilTimer.setStyleReplaceMode = function (mode) {
            switch (mode) {
                case "auto":
                case "disabled":
                case "embedded":
                case "rules":
                    // case "sheets":
                    if (styleReplaceMode !== mode) {
                        if ("disabled" !== styleReplaceMode && 1 !== speed) {
                            updateStyle(1);
                        }
                        styleReplaceMode = mode;
                        if ("disabled" !== styleReplaceMode && 1 !== speed) {
                            updateStyle();
                        }
                    }
                    break;
                default:
                    console.error("setStyleReplaceMode(".concat(JSON.stringify(mode), " as \"auto\" | \"disabled\" | \"embedded\" | \"rules\");"));
                    break;
            }
        };
        EvilTimer.setSpeed = function (rate) {
            if (0 == rate) {
                EvilTimer.pause();
            }
            else {
                setAnkerAt();
                speed = rate;
                updateStyle();
            }
        };
        EvilTimer.evilSetTimeout = function (callback, wait) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            return vanillaSetTimeout(function () {
                if (isPaused) {
                    susppendedTasks.push(function () { return callback.apply(void 0, args); });
                }
                else {
                    callback.apply(void 0, args);
                }
            }, undefined === wait ? wait : wait / Math.abs(speed));
        };
        EvilTimer.evilSetInterval = function (callback, wait) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var pushed = false;
            return vanillaSetInteral(function () {
                if (isPaused) {
                    if (!pushed) {
                        susppendedTasks.push(function () { return callback.apply(void 0, args); });
                        pushed = true;
                    }
                }
                else {
                    pushed = false;
                    callback.apply(void 0, args);
                }
            }, undefined === wait ? wait : wait / Math.abs(speed));
        };
        EvilTimer.evilRequestAnimationFrame = function (callback) { return vanillaRequestAnimationFrame(function (_tick) {
            if (isPaused) {
                susppendedTasks.push(function () { return callback(EvilTimer.getEvilPerformanceNow()); });
            }
            else {
                callback(EvilTimer.getEvilPerformanceNow());
            }
        }); };
        var Vanilla;
        (function (Vanilla) {
            Vanilla.Date = function _a() {
                var _newTarget = this && this instanceof _a ? this.constructor : void 0;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _newTarget ? new (VanillaDate.bind.apply(VanillaDate, __spreadArray([void 0], args, false)))() : VanillaDate.apply(void 0, args);
            };
            Vanilla.Date.parse = VanillaDate.parse;
            Vanilla.Date.UTC = VanillaDate.UTC;
            Vanilla.Date.now = VanillaDate.now;
            Vanilla.setTimeout = function (callback, wait) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                return vanillaSetTimeout.apply(void 0, __spreadArray([callback,
                    wait], args, false));
            };
            Vanilla.setInterval = function (callback, wait) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                return vanillaSetInteral.apply(void 0, __spreadArray([callback,
                    wait], args, false));
            };
        })(Vanilla = EvilTimer.Vanilla || (EvilTimer.Vanilla = {}));
        EvilTimer.set = function (config) {
            if ("boolean" === typeof config) {
                if (config) {
                    gThis.EvilTimer = EvilTimer;
                    gThis.Date = EvilTimer.EvilDate;
                    gThis.setTimeout = EvilTimer.evilSetTimeout;
                    gThis.setInterval = EvilTimer.evilSetInterval;
                    if (window) {
                        window.requestAnimationFrame = EvilTimer.evilRequestAnimationFrame;
                    }
                }
                else {
                    // delete gThis.EvilTimer;
                    gThis.Date = VanillaDate;
                    gThis.setTimeout = vanillaSetTimeout;
                    gThis.setInterval = vanillaSetInteral;
                    if (window) {
                        window.requestAnimationFrame = vanillaRequestAnimationFrame;
                    }
                }
            }
            else {
                if (undefined !== config.disabled && "boolean" === typeof config.disabled) {
                    EvilTimer.set(!config.disabled);
                }
                if (undefined !== config.styleReplaceMode) {
                    EvilTimer.setStyleReplaceMode(config.styleReplaceMode);
                }
                if (undefined !== config.date) {
                    EvilTimer.setDate(config.date);
                }
                if (undefined !== config.speed) {
                    EvilTimer.setSpeed(config.speed);
                }
                if (undefined !== config.pause) {
                    if (config.pause) {
                        EvilTimer.pause();
                    }
                    else {
                        EvilTimer.unpause();
                    }
                }
            }
        };
        EvilTimer.debugKey = "evil-timer.debug";
        EvilTimer.isDebug = function () { var _a; return JSON.parse((_a = window.localStorage.getItem(EvilTimer.debugKey)) !== null && _a !== void 0 ? _a : "false"); };
        EvilTimer.debugOn = function () { return window.localStorage.setItem(EvilTimer.debugKey, JSON.stringify(true)); };
        EvilTimer.debugOff = function () { return window.localStorage.removeItem(EvilTimer.debugKey); };
        EvilTimer.getStatus = function () {
            var vanilla = new VanillaDate();
            var evil = new EvilTimer.EvilDate();
            var result = {
                enabled: gThis.EvilTimer === EvilTimer,
                debug: EvilTimer.isDebug(),
                speed: speed,
                isPaused: isPaused,
                susppendedTasksCount: susppendedTasks.length,
                date: {
                    vanilla: {
                        text: vanilla.toLocaleString(),
                        tick: vanilla.getTime(),
                    },
                    evil: {
                        text: evil.toLocaleString(),
                        tick: evil.getTime(),
                    }
                }
            };
            return result;
        };
        var getConfigFromUrl = function () {
            var _a, _b, _c, _d;
            if (EvilTimer.isDebug()) {
                try {
                    return (_d = (_c = (_b = (_a = location.href
                        .split("#")[0]
                        .split("?")[1]) === null || _a === void 0 ? void 0 : _a.split("&")) === null || _b === void 0 ? void 0 : _b.filter(function (i) { return i.startsWith("evil-timer="); })) === null || _c === void 0 ? void 0 : _c.map(function (i) { return JSON.parse(decodeURIComponent(i.substr("evil-timer=".length))); })) === null || _d === void 0 ? void 0 : _d[0];
                }
                catch (err) {
                    console.log(err);
                }
            }
            return null;
        };
        var globalEvilTimerConfig = gThis.evilTimerConfig;
        if (undefined !== globalEvilTimerConfig && "boolean" !== typeof globalEvilTimerConfig) {
            var listener = type_1.EvilType.Error.makeListener("evilTimerConfig");
            if (!EvilTimer.Type.isEvilTimerConfigType(globalEvilTimerConfig, listener)) {
                console.error("ðŸš« Invalid evilTimerConfig(in JavaScript)");
                console.error(listener);
            }
        }
        if ("object" === typeof globalEvilTimerConfig && "boolean" === typeof globalEvilTimerConfig.debug) {
            if (globalEvilTimerConfig.debug) {
                EvilTimer.debugOn();
            }
            else {
                EvilTimer.debugOff();
            }
        }
        var configFromUrl = getConfigFromUrl();
        if (undefined !== configFromUrl && null !== configFromUrl && "boolean" !== typeof configFromUrl) {
            var listener = type_1.EvilType.Error.makeListener("configFromUrl");
            if (!EvilTimer.Type.isEvilTimerConfigType(configFromUrl, listener)) {
                console.error("ðŸš« Invalid evil-timer(in URL Parameter)");
                console.error(listener);
            }
        }
        var configOrBoolean = ((_b = configFromUrl !== null && configFromUrl !== void 0 ? configFromUrl : gThis.evilTimerConfig) !== null && _b !== void 0 ? _b : true);
        var evilTimerConfig = "boolean" === typeof configOrBoolean ? { disabled: !configOrBoolean, } : configOrBoolean;
        if (!((_c = evilTimerConfig.disabled) !== null && _c !== void 0 ? _c : false)) {
            EvilTimer.set(true);
            if (!((_d = evilTimerConfig.disabledLoadMessage) !== null && _d !== void 0 ? _d : false)) {
                console.log("evil-timer.js is loaded. You can use EvilTimer commands with your own risk. see: https://github.com/wraith13/evil-timer.js");
            }
            EvilTimer.set(evilTimerConfig);
        }
    })(EvilTimer || (exports.EvilTimer = EvilTimer = {}));
});
//# sourceMappingURL=evil-timer.js/index.js.map
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
define("script/url", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Url = void 0;
    //import config from "@resource/config.json";
    var Url;
    (function (Url) {
        Url.parseParameter = function (url) {
            var result = {};
            var urlObj = new URL(url.replace(/#/g, "?"));
            var params = urlObj.searchParams;
            params.forEach(function (value, key) { return result[key] = value; });
            return result;
        };
        Url.make = function (params) {
            var url = new URL(window.location.href.replace(/#/g, "?"));
            for (var _i = 0, _a = Object.entries(params); _i < _a.length; _i++) {
                var _b = _a[_i], key = _b[0], value = _b[1];
                url.searchParams.set(key, value);
            }
            return url.toString().replace(/\?/g, "#");
        };
        Url.addParameter = function (params, key, value) {
            params[key] = value;
            return params;
        };
        Url.initialize = function () {
        };
        Url.params = Url.parseParameter(window.location.href);
    })(Url || (exports.Url = Url = {}));
});
define("script/geometry", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Geometry = void 0;
    var Geometry;
    (function (Geometry) {
        ;
        Geometry.addPoints = function (a, b) {
            return ({
                x: a.x + b.x,
                y: a.y + b.y,
            });
        };
        Geometry.subPoints = function (a, b) {
            return ({
                x: a.x - b.x,
                y: a.y - b.y,
            });
        };
        Geometry.mulPoint = function (a, b) {
            return ({
                x: a.x * b,
                y: a.y * b,
            });
        };
        Geometry.averagePoints = function (points) {
            return Geometry.mulPoint(points.reduce(Geometry.addPoints, { x: 0, y: 0, }), 1 / points.length);
        };
    })(Geometry || (exports.Geometry = Geometry = {}));
});
define("resource/config", [], {
    "applicationTitle": "Myaku-Myaku Sama",
    "repositoryUrl": "https://github.com/wraith13/myaku-myaku-sama/",
    "canonicalUrl": "https://wraith13.github.io/myaku-myaku-sama/",
    "description": "Myaku-Myaku Sama's pattern animation ( this web app is for study )",
    "noscriptMessage": "JavaScript is disabled. Please enable JavaScript.",
    "rendering": {
        "marginRate": 0.9,
        "coloringRegularFadeDuration": 500,
        "coloringRandomFadeDuration": 3000,
        "randomColoringUnitDuration": 60000,
        "antiDullnessBoost": 0.2
    },
    "coloring": {
        "regular": {
            "base": "#FFFFFF",
            "main": "#E50012",
            "accent": "#0068B6"
        },
        "monochrome": {
            "base": "#FFFFFF",
            "main": "#000000",
            "accent": "#72716F"
        },
        "silver-snow": {
            "base": "#FFFFFF",
            "main": "#C0C0C0",
            "accent": "#808080"
        },
        "cherry": {
            "base": "#FFFFFF",
            "main": "#FF69B4",
            "accent": "#FF1493"
        },
        "orchid-purple": {
            "base": "#FFFFFF",
            "main": "#800080",
            "accent": "#DA70D6"
        },
        "violet-night": {
            "base": "#FFFFFF",
            "main": "#4B0082",
            "accent": "#8A2BE2"
        },
        "sapphire-blue": {
            "base": "#FFFFFF",
            "main": "#0000FF",
            "accent": "#1E90FF"
        },
        "summer-sea": {
            "base": "#FFFFFF",
            "main": "#00CED1",
            "accent": "#20B2AA"
        },
        "lime-grass": {
            "base": "#FFFFFF",
            "main": "#32CD32",
            "accent": "#7CFC00"
        },
        "shining-sun": {
            "base": "#FFFFFF",
            "main": "#FFD700",
            "accent": "#FFA500"
        },
        "milk-chocolate": {
            "base": "#FFFFFF",
            "main": "#D2691E",
            "accent": "#8B4513"
        },
        "autumn-leaf": {
            "base": "#FFFFFF",
            "main": "#FF8C00",
            "accent": "#FF4500"
        },
        "crimzon-rose": {
            "base": "#FFFFFF",
            "main": "#DC143C",
            "accent": "#B22222"
        }
    },
    "pitch": {
        "presets": [
            0,
            0.125,
            0.25,
            0.5,
            1.0,
            2.0,
            4.0,
            8.0
        ],
        "default": 1.0
    },
    "eye": {
        "appearRate": 0.12,
        "vanishRate": 0.1,
        "whiteRate": 0.3,
        "irisRate": 0.15
    },
    "Layer": {
        "unit": {
            "moveAnimation": {
                "period": {
                    "base": 500,
                    "pseudoGaussian": 2,
                    "range": 300000
                },
                "scale": {
                    "base": 0.05,
                    "pseudoGaussian": 4,
                    "range": 0.1
                },
                "elements": [
                    1.0,
                    0.5,
                    0.25,
                    0.125
                ]
            },
            "sizeAnimation": {
                "period": {
                    "base": 750,
                    "pseudoGaussian": 2,
                    "range": 300000
                },
                "scale": {
                    "base": 0.05,
                    "pseudoGaussian": 4,
                    "range": 0.1
                },
                "elements": [
                    1.0,
                    1.0,
                    1.0,
                    1.0,
                    1.0
                ]
            },
            "appearAnimation": {
                "period": 3000
            },
            "vanishAnimation": {
                "period": 1500
            }
        },
        "eye": {
            "moveAnimation": {
                "period": {
                    "base": 500,
                    "pseudoGaussian": 2,
                    "range": 9000
                },
                "scale": {
                    "base": 0.05,
                    "pseudoGaussian": 4,
                    "range": 0.1
                },
                "elements": [
                    1.0,
                    0.5,
                    0.25,
                    0.125
                ]
            },
            "appearAnimation": {
                "period": 500
            },
            "vanishAnimation": {
                "period": 500
            }
        }
    },
    "watch": {
        "alternate": {
            "span": 47000
        },
        "dateFormat": {
            "weekday": "long",
            "year": "numeric",
            "month": "long",
            "day": "numeric"
        },
        "timeFormat": {
            "hour": "2-digit",
            "minute": "2-digit",
            "second": "2-digit"
        },
        "firstDayOfWeek": 0
    }
});
define("script/model", ["require", "exports", "resource/config"], function (require, exports, config_json_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Model = void 0;
    config_json_1 = __importDefault(config_json_1);
    var Model;
    (function (Model) {
        var canvas = document.getElementById("canvas");
        Model.pseudoGaussian = function (samples) {
            if (samples === void 0) { samples = 6; }
            var total = 0;
            for (var i = 0; i < samples; i++) {
                total += Math.random();
            }
            return total / samples;
        };
        ;
        ;
        ;
        ;
        Model.makeCircle = function (point, radius) {
            return ({
                x: point.x,
                y: point.y,
                radius: radius,
            });
        };
        ;
        ;
        ;
        Model.Data = {
            previousTimestamp: 0,
            previousPitchedTimestamp: 0,
            pitch: config_json_1.default.pitch.default,
            width: 0,
            height: 0,
            accent: { units: [], lastMadeAt: 0, lastRemovedAt: 0, },
            main: { units: [], lastMadeAt: 0, lastRemovedAt: 0, },
        };
        Model.setPitch = function (value) {
            Model.Data.pitch = value;
        };
        Model.isOutOfCanvas = function (circle) {
            var marginRate = config_json_1.default.rendering.marginRate;
            var halfDiagonalLength = Math.hypot(canvas.width, canvas.height) / 2;
            var centerX = canvas.width / 2;
            var centerY = canvas.height / 2;
            var x = (circle.x * marginRate * halfDiagonalLength) + centerX;
            var y = (circle.y * marginRate * halfDiagonalLength) + centerY;
            return (x + circle.radius * halfDiagonalLength < 0 ||
                y + circle.radius * halfDiagonalLength < 0 ||
                canvas.width < x - circle.radius * halfDiagonalLength ||
                canvas.height < y - circle.radius * halfDiagonalLength);
        };
        Model.sumValidAreas = function (layer) {
            return layer.units
                .filter(function (unit) { return !Model.isOutOfCanvas(unit.body); })
                .reduce(function (sum, unit) { return sum + Math.PI * unit.body.radius * unit.body.radius; }, 0);
        };
        Model.sumAllAreas = function (layer) {
            return layer.units
                .reduce(function (sum, unit) { return sum + Math.PI * unit.body.radius * unit.body.radius; }, 0);
        };
        Model.calculateAnimationSineIntegral = function (animation, step) {
            // return stepã§ç©åˆ†(Math.sin((animation.phase / animation.period) * Math.PI * 2));
            if (animation.period <= 0 || 0 === step) {
                return 0;
            }
            else {
                var omega = (2 * Math.PI) / animation.period;
                // âˆ«0^step sin(omega*(phase + Ï„)) dÏ„ = (cos(omega*phase) - cos(omega*(phase + step))) / omega
                var integral = (Math.cos(omega * animation.phase) - Math.cos(omega * (animation.phase + step))) / omega;
                return integral * animation.scale;
            }
        };
        Model.accumulateAnimationSineIntegral = function (animations, step) {
            return animations.reduce(function (sum, animation) { return sum + Model.calculateAnimationSineIntegral(animation, step); }, 0);
        };
        Model.accumulateAnimationSize = function (animations, step) {
            return animations.reduce(function (product, animation) {
                var phase = animation.phase + step;
                return product + Math.pow(Math.sin((phase / animation.period) * Math.PI), 2) * 0.5 * animation.scale;
            }, 0.0);
        };
        Model.updateAnimation = function (animation, step) {
            animation.phase += step;
            while (animation.period <= animation.phase) {
                animation.phase -= animation.period;
            }
        };
        Model.updateAnimations = function (animations, step) {
            return animations.forEach(function (animation) { return Model.updateAnimation(animation, step); });
        };
        Model.updateFloatAnimation = function (floatAnimation, step) {
            Model.updateAnimations(floatAnimation.x, step);
            Model.updateAnimations(floatAnimation.y, step);
        };
        Model.makeAnimation = function (specific, scaleRate) {
            var period = specific.period.base + (Model.pseudoGaussian(specific.period.pseudoGaussian) * specific.period.range);
            var phase = period * Math.random();
            var scale = (specific.scale.base + (Model.pseudoGaussian(specific.scale.pseudoGaussian) * specific.scale.range)) * scaleRate;
            return { phase: phase, period: period, scale: scale, };
        };
        Model.makeUnitAnimation = function () {
            // const shortSide = Math.min(window.innerWidth, window.innerHeight) *3.0;
            // const xRatio = window.innerWidth / shortSide;
            // const yRatio = window.innerHeight / shortSide;
            var xRatio = 1.0;
            var yRatio = 1.0;
            var result = {
                moveAnimation: {
                    x: config_json_1.default.Layer.unit.moveAnimation.elements.map(function (i) { return Model.makeAnimation(config_json_1.default.Layer.unit.moveAnimation, i * xRatio); }),
                    y: config_json_1.default.Layer.unit.moveAnimation.elements.map(function (i) { return Model.makeAnimation(config_json_1.default.Layer.unit.moveAnimation, i * yRatio); }),
                },
                sizeAnimation: config_json_1.default.Layer.unit.sizeAnimation.elements.map(function (i) { return Model.makeAnimation(config_json_1.default.Layer.unit.sizeAnimation, i); }),
            };
            return result;
        };
        Model.makeUnit = function (point) {
            var body = Model.makeCircle(point, (Math.pow(Model.pseudoGaussian(4), 2) * 0.19) + 0.01);
            var result = {
                body: body,
                scale: body.radius,
                animation: Model.makeUnitAnimation(),
            };
            //updateUnit(result, Math.random() *10000);
            result.animation.appearAnimation =
                {
                    period: config_json_1.default.Layer.unit.appearAnimation.period,
                    phase: 0,
                    scale: result.scale,
                };
            return result;
        };
        Model.makeEye = function () {
            var point = { x: 0, y: 0, };
            var xRatio = 1.0;
            var yRatio = 1.0;
            var white = Model.makeCircle(point, config_json_1.default.eye.whiteRate);
            var iris = Model.makeCircle(point, config_json_1.default.eye.irisRate);
            var result = {
                white: white,
                iris: iris,
                animation: {
                    moveAnimation: {
                        x: config_json_1.default.Layer.eye.moveAnimation.elements.map(function (i) { return Model.makeAnimation(config_json_1.default.Layer.eye.moveAnimation, i * xRatio); }),
                        y: config_json_1.default.Layer.eye.moveAnimation.elements.map(function (i) { return Model.makeAnimation(config_json_1.default.Layer.eye.moveAnimation, i * yRatio); }),
                    }
                },
            };
            result.animation.appearAnimation =
                {
                    period: config_json_1.default.Layer.eye.appearAnimation.period,
                    phase: 0,
                    scale: config_json_1.default.eye.whiteRate,
                };
            return result;
        };
        var updateIris = function (eye) {
            eye.iris.x = eye.white.x + eye.white.x * (config_json_1.default.eye.whiteRate - config_json_1.default.eye.irisRate) / (1 - config_json_1.default.eye.whiteRate);
            eye.iris.y = eye.white.y + eye.white.y * (config_json_1.default.eye.whiteRate - config_json_1.default.eye.irisRate) / (1 - config_json_1.default.eye.whiteRate);
            eye.iris.radius = eye.white.radius * (config_json_1.default.eye.irisRate / config_json_1.default.eye.whiteRate);
        };
        var updateEye = function (unit, step) {
            var _a;
            if (unit.eye) {
                var eye = unit.eye;
                var rate = 0.005;
                eye.white.x += Model.accumulateAnimationSineIntegral(eye.animation.moveAnimation.x, step) * rate;
                eye.white.y += Model.accumulateAnimationSineIntegral(eye.animation.moveAnimation.y, step) * rate;
                var distance = Math.hypot(eye.white.x, eye.white.y);
                var maxDistance = 0.95;
                if (maxDistance < distance + config_json_1.default.eye.whiteRate) {
                    eye.white.x *= (maxDistance - config_json_1.default.eye.whiteRate) / distance;
                    eye.white.y *= (maxDistance - config_json_1.default.eye.whiteRate) / distance;
                }
                Model.updateAnimations(eye.animation.moveAnimation.x, step);
                Model.updateAnimations(eye.animation.moveAnimation.y, step);
                var transion = (_a = eye.animation.appearAnimation) !== null && _a !== void 0 ? _a : eye.animation.vanishAnimation;
                if (transion) {
                    transion.phase += step;
                    if (eye.animation.vanishAnimation) {
                        eye.white.radius = config_json_1.default.eye.whiteRate * (1.0 - (transion.phase / transion.period));
                        if (transion.period <= transion.phase) {
                            // eye.animation.vanishAnimation = undefined;
                            unit.eye = undefined;
                        }
                    }
                    else {
                        eye.white.radius = config_json_1.default.eye.whiteRate * (transion.phase / transion.period);
                        if (transion.period <= transion.phase) {
                            eye.animation.appearAnimation = undefined;
                        }
                    }
                }
                if (undefined !== unit.eye) {
                    updateIris(eye);
                }
            }
        };
        Model.updateUnit = function (layer, unit, step) {
            var _a;
            var rate = 0.0005;
            unit.body.x += Model.accumulateAnimationSineIntegral(unit.animation.moveAnimation.x, step) * rate;
            unit.body.y += Model.accumulateAnimationSineIntegral(unit.animation.moveAnimation.y, step) * rate;
            var transion = (_a = unit.animation.appearAnimation) !== null && _a !== void 0 ? _a : unit.animation.vanishAnimation;
            if (transion) {
                transion.phase += step;
                if (unit.animation.vanishAnimation) {
                    unit.body.radius = transion.scale * (1.0 - (transion.phase / transion.period));
                    if (transion.period <= transion.phase) {
                        unit.animation.vanishAnimation = undefined;
                    }
                }
                else {
                    unit.body.radius = transion.scale * (transion.phase / transion.period);
                    if (transion.period <= transion.phase) {
                        unit.animation.appearAnimation = undefined;
                    }
                }
            }
            var scale = transion ? unit.body.radius : unit.scale;
            unit.body.radius = scale * (1 + (Model.accumulateAnimationSize(unit.animation.sizeAnimation, step) * 2.0));
            Model.updateFloatAnimation(unit.animation.moveAnimation, step);
            Model.updateAnimations(unit.animation.sizeAnimation, step);
            if (layer === Model.Data.main && !Model.isOutOfCanvas(unit.body)) {
                if (undefined === unit.eye && config_json_1.default.eye.appearRate <= unit.body.radius) {
                    unit.eye = Model.makeEye();
                }
            }
            if (undefined !== unit.eye && undefined === unit.eye.animation.vanishAnimation && unit.body.radius < config_json_1.default.eye.vanishRate) {
                unit.eye.animation.vanishAnimation =
                    {
                        period: config_json_1.default.Layer.eye.vanishAnimation.period,
                        phase: 0,
                        scale: unit.eye.white.radius,
                    };
            }
            updateEye(unit, step);
        };
        Model.updateLayer = function (layer, timestamp, step) {
            var shortSide = Math.min(window.innerWidth, window.innerHeight);
            var longSide = Math.max(window.innerWidth, window.innerHeight);
            var validVolume = Model.sumValidAreas(layer);
            var allVolume = Model.sumAllAreas(layer);
            var longSideRatio = 0 < shortSide ? longSide / shortSide : 0;
            var validAreaRatio = validVolume / (longSideRatio * 2.0);
            var allAreaRatio = allVolume / Math.min(longSideRatio * 2.0, validVolume);
            if (validAreaRatio < 0.5) {
                var makeUnitCooldown = 1000 * validAreaRatio;
                if (makeUnitCooldown <= timestamp - layer.lastMadeAt) {
                    layer.units.push(Model.makeUnit({ x: (Model.pseudoGaussian(1) - 0.5) * window.innerWidth / shortSide, y: (Model.pseudoGaussian(1) - 0.5) * window.innerHeight / shortSide, }));
                    layer.lastMadeAt = timestamp;
                }
            }
            else if (1.0 < allAreaRatio || (0.5 < allAreaRatio && layer.lastRemovedAt + 3000 < timestamp)) {
                var removeUnitCooldown = 1000 / allAreaRatio;
                if (removeUnitCooldown <= timestamp - layer.lastRemovedAt) {
                    var target = layer.units.filter(function (unit) { return undefined === unit.animation.vanishAnimation; })[0];
                    if (target) {
                        target.animation.vanishAnimation =
                            {
                                period: config_json_1.default.Layer.unit.vanishAnimation.period,
                                phase: 0,
                                scale: target.scale,
                            };
                        layer.lastRemovedAt = timestamp;
                    }
                }
            }
            layer.units.forEach(function (unit) { return Model.updateUnit(layer, unit, step); });
            var gabages = layer.units.filter(function (unit) { return unit.body.radius <= 0; });
            gabages.forEach(function (garbage) {
                var index = layer.units.indexOf(garbage);
                if (0 <= index) {
                    layer.units.splice(index, 1);
                }
            });
        };
        Model.PixelRatioModeKeys = ["thirty-second", "sixteenth", "eighth", "quarter", "half", "regular", "full",];
        var pixelRatioMode = "regular";
        Model.togglePixelRatioMode = function (value) {
            if (typeof value === "boolean" || undefined === value) {
                var currentIndex = Model.PixelRatioModeKeys.indexOf(pixelRatioMode);
                var nextIndex = (Model.PixelRatioModeKeys.length + currentIndex + (false !== value ? 1 : -1)) % Model.PixelRatioModeKeys.length;
                pixelRatioMode = Model.PixelRatioModeKeys[nextIndex];
            }
            else {
                if (Model.PixelRatioModeKeys.includes(value)) {
                    pixelRatioMode = value;
                }
            }
            console.log("\uD83D\uDDA5\uFE0F Quality changed: ".concat(pixelRatioMode));
            Model.updateStretch();
        };
        Model.getPixcelRatioLevel = function () {
            switch (pixelRatioMode) {
                case "thirty-second":
                    return 1;
                case "sixteenth":
                    return 2;
                case "eighth":
                    return 3;
                case "quarter":
                    return 4;
                case "half":
                    return 5;
                case "regular":
                    return 6;
                case "full":
                    return 7;
            }
        };
        Model.getPixcelRatio = function () {
            var _a;
            switch (pixelRatioMode) {
                case "thirty-second":
                    return 0.03125;
                case "sixteenth":
                    return 0.0625;
                case "eighth":
                    return 0.125;
                case "quarter":
                    return 0.25;
                case "half":
                    return 0.5;
                case "regular":
                    return 1;
                case "full":
                    return (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1;
            }
        };
        Model.updateStretch = function () {
            var devicePixelRatio = Model.getPixcelRatio();
            canvas.width = Model.Data.width = window.innerWidth * devicePixelRatio;
            canvas.height = Model.Data.height = window.innerHeight * devicePixelRatio;
        };
        Model.updateData = function (rawTimestamp) {
            var result = false;
            var devicePixelRatio = Model.getPixcelRatio();
            if (window.innerWidth * devicePixelRatio !== Model.Data.width || window.innerHeight * devicePixelRatio !== Model.Data.height) {
                Model.updateStretch();
                result = true;
            }
            var rawStep = 0 < Model.Data.previousTimestamp ? Math.min(rawTimestamp - Model.Data.previousTimestamp, 500) : 0;
            var step = rawStep * Model.Data.pitch;
            if (0 < step) {
                Model.Data.previousPitchedTimestamp += step;
                Model.updateLayer(Model.Data.accent, Model.Data.previousPitchedTimestamp, step);
                Model.updateLayer(Model.Data.main, Model.Data.previousPitchedTimestamp, step);
                result = true;
            }
            Model.Data.previousTimestamp = rawTimestamp;
            return result;
        };
    })(Model || (exports.Model = Model = {}));
});
define("script/ui", ["require", "exports", "script/model", "resource/config"], function (require, exports, model_1, config_json_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UI = void 0;
    config_json_2 = __importDefault(config_json_2);
    var UI;
    (function (UI) {
        var getElementById = function (tag, id) {
            var element = document.getElementById(id);
            if (!element) {
                throw new Error("\uD83E\uDD8B FIXME: Element not found: ".concat(id));
            }
            if (tag !== element.tagName.toLowerCase()) {
                throw new Error("\uD83E\uDD8B FIXME: Element is not <".concat(tag, ">: ").concat(id));
            }
            return element;
        };
        UI.canvas = getElementById("canvas", "canvas");
        UI.overlayPanel = getElementById("div", "overlay-panel");
        UI.time = getElementById("time", "time");
        UI.date = getElementById("time", "date");
        UI.fpsDiv = getElementById("div", "fps");
        UI.coloringButton = getElementById("button", "coloring-button");
        UI.hdButton = getElementById("button", "hd-button");
        UI.pitchButton = getElementById("button", "pitch-button");
        UI.watchButton = getElementById("button", "watch-button");
        UI.fpsButton = getElementById("button", "fps-button");
        UI.fullscreenButton = getElementById("button", "fullscreen-button");
        UI.jumpOutButton = getElementById("button", "jump-out-button");
        UI.fullscreenEnabled = document.fullscreenEnabled || document.webkitFullscreenEnabled;
        UI.isInIframe = window.top !== window.self;
        UI.setAriaHidden = function (element, hidden) {
            var attributeKey = "aria-hidden";
            if (hidden) {
                var attribute = document.createAttribute(attributeKey);
                attribute.value = "true";
                element.attributes.setNamedItem(attribute);
            }
            else {
                if (element.attributes.getNamedItem(attributeKey)) {
                    element.attributes.removeNamedItem(attributeKey);
                }
            }
        };
        UI.WatchColorList = ["none", "white", "black", "rainbow"];
        UI.watchColor = "none";
        UI.updateWatchVisibility = function () {
            if ("none" !== UI.watchColor) {
                UI.WatchColorList.forEach(function (color) { return UI.overlayPanel.classList.toggle(color, UI.watchColor === color); });
                UI.time.style.display = "block";
                UI.date.style.display = "block";
                UI.setAriaHidden(UI.time, false);
                UI.setAriaHidden(UI.date, false);
            }
            else {
                UI.time.style.display = "none";
                UI.date.style.display = "none";
                UI.setAriaHidden(UI.time, true);
                UI.setAriaHidden(UI.date, true);
            }
        };
        UI.updateRoundBar = function (button, properties) {
            // console.log("updateRoundBar", button, properties);
            /* For older environments where the 'initial-value' setting isn't supported, all values must be specified. */
            UI.setStyle(button, "--low", properties.low.toFixed(3));
            UI.setStyle(button, "--high", properties.high.toFixed(3));
            UI.setStyle(button, "--rotate", properties.rotate.toFixed(3));
        };
        var coloringRoundBarIndex = 0;
        var mod = function (n, m) { return ((n % m) + m) % m; };
        UI.updateColoringRoundBar = function () {
            var keys = Object.keys(config_json_2.default.coloring).concat("random");
            var max = keys.length - 1;
            UI.updateRoundBar(UI.coloringButton, max <= mod(coloringRoundBarIndex, keys.length) ?
                {
                    low: 0,
                    high: 1,
                    rotate: (coloringRoundBarIndex - Math.floor(coloringRoundBarIndex / keys.length)) / max,
                } :
                {
                    low: 0 / max,
                    high: 1 / max,
                    rotate: (coloringRoundBarIndex - Math.floor(coloringRoundBarIndex / keys.length)) / max,
                });
        };
        UI.coloring = "regular";
        UI.toggleColoring = function (style) {
            var keys = Object.keys(config_json_2.default.coloring).concat("random");
            if (typeof style === "boolean" || undefined === style) {
                var currentIndex = keys.indexOf(UI.coloring);
                var nextIndex = (keys.length + currentIndex + (false !== style ? 1 : -1)) % keys.length;
                console.log({ currentIndex: currentIndex, nextIndex: nextIndex, keysLength: keys.length, style: style });
                UI.coloring = keys[nextIndex];
                coloringRoundBarIndex += false !== style ? 1 : -1;
            }
            else {
                if (keys.includes(style)) {
                    UI.coloring = style;
                    coloringRoundBarIndex = keys.indexOf(style);
                }
            }
            UI.updateColoringRoundBar();
            console.log("\uD83C\uDFA8 Coloring changed: ".concat(UI.coloring));
        };
        UI.updateHdRoundBar = function () { return UI.updateRoundBar(UI.hdButton, {
            low: 0 / model_1.Model.PixelRatioModeKeys.length,
            high: model_1.Model.getPixcelRatioLevel() / model_1.Model.PixelRatioModeKeys.length,
            rotate: 0,
        }); };
        UI.updatePitchRoundBar = function () { return UI.updateRoundBar(UI.pitchButton, {
            low: 0 / config_json_2.default.pitch.presets.length,
            high: config_json_2.default.pitch.presets.indexOf(model_1.Model.Data.pitch) / (config_json_2.default.pitch.presets.length - 1),
            rotate: 0,
        }); };
        UI.togglePitch = function (value) {
            var presets = config_json_2.default.pitch.presets;
            if (typeof value === "boolean" || undefined === value) {
                var currentIndex = presets.indexOf(model_1.Model.Data.pitch);
                var nextIndex = (presets.length + currentIndex + (false !== value ? 1 : -1)) % presets.length;
                model_1.Model.setPitch(presets[nextIndex]);
            }
            else {
                if (presets.includes(value)) {
                    model_1.Model.setPitch(value);
                }
            }
            UI.updatePitchRoundBar();
            console.log("\uD83C\uDFB5 Pitch changed: ".concat(model_1.Model.Data.pitch));
        };
        var watchRoundBarIndex = 0;
        UI.updateWatchRoundBar = function () { return UI.updateRoundBar(UI.watchButton, {
            low: "none" === UI.watchColor ? 1 / (UI.WatchColorList.length - 1) : 0,
            high: 1 / (UI.WatchColorList.length - 1),
            rotate: (watchRoundBarIndex - Math.floor(watchRoundBarIndex / UI.WatchColorList.length) - 1) / (UI.WatchColorList.length - 1),
        }); };
        UI.toggleWatchDisplay = function (value) {
            if (typeof value === "boolean" || undefined === value) {
                var currentIndex = UI.WatchColorList.indexOf(UI.watchColor);
                var nextIndex = (UI.WatchColorList.length + currentIndex + (false !== value ? 1 : -1)) % UI.WatchColorList.length;
                UI.watchColor = UI.WatchColorList[nextIndex];
                watchRoundBarIndex += false !== value ? 1 : -1;
            }
            else {
                if (UI.WatchColorList.includes(value)) {
                    UI.watchColor = value;
                    watchRoundBarIndex = UI.WatchColorList.indexOf(value);
                }
            }
            UI.updateWatchVisibility();
            UI.updateWatchRoundBar();
            console.log("\uD83D\uDD70\uFE0F Watch changed: ".concat(UI.watchColor));
        };
        UI.toggleFpsDisplay = function () {
            if ("none" === UI.fpsDiv.style.display) {
                UI.fpsDiv.style.display = "block";
                UI.fpsButton.classList.add("on");
            }
            else {
                UI.fpsDiv.style.display = "none";
                UI.fpsButton.classList.remove("on");
            }
        };
        UI.toggleFullScreen = function () {
            var elem = document.documentElement;
            if (document.fullscreenEnabled) {
                if (!document.fullscreenElement) {
                    elem.requestFullscreen();
                }
                else {
                    document.exitFullscreen();
                }
            }
            else {
                if (document.webkitFullscreenEnabled) {
                    if (!document.webkitFullscreenElement) {
                        elem.webkitRequestFullscreen();
                    }
                    else {
                        document.webkitExitFullscreen();
                    }
                }
            }
        };
        UI.updateFullscreenState = function () {
            var isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
            UI.fullscreenButton.classList.toggle("on", Boolean(isFullscreen));
            UI.resize();
        };
        var ToggleClassForWhileTimer = /** @class */ (function () {
            function ToggleClassForWhileTimer() {
                var _this = this;
                this.isInTimer = function () { return undefined !== _this.timer; };
                this.timer = undefined;
            }
            ToggleClassForWhileTimer.prototype.start = function (element, token, span, onEnd) {
                var _this = this;
                if (this.isInTimer()) {
                    clearTimeout(this.timer);
                }
                element.classList.toggle(token, true);
                this.timer = setTimeout(function () {
                    // if (config.log["ToggleClassForWhileTimer.Timeout"])
                    // {
                    //     console.log("âŒ›ï¸ ToggleClassForWhileTimer.Timeout", element, token, span);
                    // }
                    _this.timer = undefined;
                    element.classList.toggle(token, false);
                    onEnd === null || onEnd === void 0 ? void 0 : onEnd();
                }, span);
            };
            return ToggleClassForWhileTimer;
        }());
        UI.ToggleClassForWhileTimer = ToggleClassForWhileTimer;
        var mouseMoveTimer = new ToggleClassForWhileTimer();
        UI.mousemove = function () {
            return mouseMoveTimer.start(document.body, "mousemove", 3000);
        };
        UI.resize = function () {
            // Fallback for older environments
            UI.setStyle(document.documentElement, "--short-side", "".concat(Math.min(window.innerWidth, window.innerHeight) / 100, "px"));
            console.log("\uD83D\uDD04 Resize: ".concat(window.innerWidth, "x").concat(window.innerHeight));
        };
        UI.setTextContent = function (element, text) {
            if (element.textContent !== text) {
                element.textContent = text;
                return true;
            }
            return false;
        };
        UI.setAttribute = function (element, name, value) {
            var _a;
            if (((_a = element.getAttribute(name)) !== null && _a !== void 0 ? _a : "") !== (value !== null && value !== void 0 ? value : "")) {
                if (undefined === value || null === value) {
                    element.removeAttribute(name);
                }
                else {
                    element.setAttribute(name, value);
                }
                return true;
            }
            return false;
        };
        UI.setStyle = function (element, name, value) {
            var _a;
            if (((_a = element.style.getPropertyValue(name)) !== null && _a !== void 0 ? _a : "") !== (value !== null && value !== void 0 ? value : "")) {
                if (undefined === value || null === value || "" === value) {
                    element.style.removeProperty(name);
                }
                else {
                    element.style.setProperty(name, value);
                }
                return true;
            }
            return false;
        };
    })(UI || (exports.UI = UI = {}));
});
define("script/render", ["require", "exports", "script/geometry", "script/model", "script/ui", "resource/config"], function (require, exports, geometry_js_1, model_2, ui_1, config_json_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Render = void 0;
    config_json_3 = __importDefault(config_json_3);
    var Render;
    (function (Render) {
        var isRandomColoring = function () {
            return undefined === config_json_3.default.coloring[ui_1.UI.coloring];
        };
        var getColoring = function () {
            if (isRandomColoring()) {
                var index = Math.floor(Math.random() * Object.keys(config_json_3.default.coloring).length);
                var key = Object.keys(config_json_3.default.coloring)[index];
                var result = config_json_3.default.coloring[key];
                if (isSameColoring(newColors, result)) {
                    index = (index + 1) % Object.keys(config_json_3.default.coloring).length;
                    key = Object.keys(config_json_3.default.coloring)[index];
                    result = config_json_3.default.coloring[key];
                }
                return result;
            }
            else {
                return config_json_3.default.coloring[ui_1.UI.coloring];
            }
        };
        var getColors = function () {
            var coloring = getColoring();
            return { base: coloring.base, main: coloring.main, accent: coloring.accent, };
        };
        var changedColoringAt = 0;
        var oldColors = getColors();
        var newColors = getColors();
        var previousColors = getColors();
        var isSameColoring = function (a, b) {
            return a.base === b.base && a.main === b.main && a.accent === b.accent;
        };
        Render.updateColoring = function () {
            var colors = getColors();
            if (!isSameColoring(newColors, colors)) {
                oldColors = getCurrentColors();
                newColors = colors;
                changedColoringAt = performance.now();
            }
        };
        var mixColor = function (oldColor, newColor, rate) {
            var boost = 1.0 + (config_json_3.default.rendering.antiDullnessBoost * Math.sin(Math.PI * rate)); // Adjustment to reduce dullness of intermediate colors
            var oldR = parseInt(oldColor.slice(1, 3), 16);
            var oldG = parseInt(oldColor.slice(3, 5), 16);
            var oldB = parseInt(oldColor.slice(5, 7), 16);
            var newR = parseInt(newColor.slice(1, 3), 16);
            var newG = parseInt(newColor.slice(3, 5), 16);
            var newB = parseInt(newColor.slice(5, 7), 16);
            var currR = Math.round(Math.min((oldR + (newR - oldR) * rate) * boost, 255));
            var currG = Math.round(Math.min((oldG + (newG - oldG) * rate) * boost, 255));
            var currB = Math.round(Math.min((oldB + (newB - oldB) * rate) * boost, 255));
            return "#".concat(currR.toString(16).padStart(2, "0")).concat(currG.toString(16).padStart(2, "0")).concat(currB.toString(16).padStart(2, "0"));
        };
        var mixColors = function (oldColors, newColors, rate) {
            return ({
                base: mixColor(oldColors.base, newColors.base, rate),
                main: mixColor(oldColors.main, newColors.main, rate),
                accent: mixColor(oldColors.accent, newColors.accent, rate),
            });
        };
        var getCurrentColors = function () {
            var now = performance.now();
            var span = isRandomColoring() ?
                config_json_3.default.rendering.coloringRandomFadeDuration :
                config_json_3.default.rendering.coloringRegularFadeDuration;
            var rate = (now - changedColoringAt) / span;
            if (1.0 <= rate) {
                return newColors;
            }
            else if (rate <= 0.0) {
                return oldColors;
            }
            else {
                return mixColors(oldColors, newColors, rate);
            }
        };
        var context = ui_1.UI.canvas.getContext("2d");
        var mappingCircle = function (parent, circle) {
            return ({
                x: (circle.x * parent.radius) + parent.x,
                y: (circle.y * parent.radius) + parent.y,
                radius: circle.radius * parent.radius,
            });
        };
        // const remappingCircle = (parent: Model.Circle, circle: Model.Circle): Model.Circle =>
        // ({
        //     x: (circle.x -parent.x) /parent.radius,
        //     y: (circle.y -parent.y) /parent.radius,
        //     radius: circle.radius /parent.radius,
        // });
        // export const remappingPoint = (parent: Model.Circle, point: Geometry.Point): Geometry.Point =>
        // ({
        //     x: (point.x -parent.x) /parent.radius,
        //     y: (point.y -parent.y) /parent.radius,
        // });
        Render.getCanvasCircle = function () {
            return ({
                x: ui_1.UI.canvas.width / 2,
                y: ui_1.UI.canvas.height / 2,
                radius: Math.hypot(ui_1.UI.canvas.width, ui_1.UI.canvas.height) / 2,
            });
        };
        var hasFusionPath = function (fusionStatus) {
            return ["none", "inclusion"].indexOf(fusionStatus) < 0;
        };
        var isContacted = function (fusionStatus) {
            return 0 <= ["overlap", "inclusion"].indexOf(fusionStatus);
        };
        var getFusionStatus = function (data) {
            if (data.fusionLimit < data.distance) {
                return "none";
            }
            if (data.wireLimit < data.distance) {
                return "wired";
            }
            if (data.sumRadius < data.distance) {
                return "near";
            }
            if (data.sumRadius - data.minRadius * 2 < data.distance) {
                return "overlap";
            }
            return "inclusion";
        };
        var fusionLimitRate = 1.0;
        var wireLimitRate = 0.7;
        var minCurveAngleRate = 1.0;
        var drawFusionPath = function (circles, color) {
            for (var i = 0; i < circles.length; i++) {
                for (var j = i + 1; j < circles.length; j++) {
                    var a = circles[i];
                    var b = circles[j];
                    var sumRadius = a.radius + b.radius;
                    var minRadius = Math.min(a.radius, b.radius);
                    //const maxRadius = Math.max(a.radius, b.radius);
                    var fusionLimit = sumRadius + (minRadius * fusionLimitRate);
                    var wireLimit = sumRadius + (fusionLimit - sumRadius) * wireLimitRate;
                    var dx = b.x - a.x;
                    var dy = b.y - a.y;
                    var angle = Math.atan2(dy, dx);
                    var distance = Math.hypot(dx, dy);
                    var fusionStatus = getFusionStatus({ sumRadius: sumRadius, minRadius: minRadius, wireLimit: wireLimit, fusionLimit: fusionLimit, distance: distance, });
                    if (hasFusionPath(fusionStatus)) {
                        var contactAngle = isContacted(fusionStatus) ? Math.acos(distance / sumRadius) : null;
                        var curveAngleRate = minCurveAngleRate *
                            (isContacted(fusionStatus) ? 1 :
                                Math.pow(((fusionLimit - sumRadius) - (distance - sumRadius)) / (fusionLimit - sumRadius), 0.3));
                        var minCurveAngle1 = curveAngleRate * minRadius / a.radius;
                        var minCurveAngle2 = curveAngleRate * minRadius / b.radius;
                        var theta1 = Math.min((contactAngle !== null && contactAngle !== void 0 ? contactAngle : 0) + minCurveAngle1, Math.PI - minCurveAngle1);
                        var theta2 = Math.min((contactAngle !== null && contactAngle !== void 0 ? contactAngle : 0) + minCurveAngle2, Math.PI - minCurveAngle2);
                        // å·¦ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆ (tp1 on c1, tp3 on c2)
                        var tp1 = {
                            x: a.x + a.radius * Math.cos(angle + theta1),
                            y: a.y + a.radius * Math.sin(angle + theta1)
                        };
                        var tp3 = {
                            x: b.x + b.radius * Math.cos(angle + (Math.PI + theta2)),
                            y: b.y + b.radius * Math.sin(angle + (Math.PI + theta2))
                        };
                        // å³ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆ (tp2 on c1, tp4 on c2)
                        var tp2 = {
                            x: a.x + a.radius * Math.cos(angle - theta1),
                            y: a.y + a.radius * Math.sin(angle - theta1)
                        };
                        var tp4 = {
                            x: b.x + b.radius * Math.cos(angle + (Math.PI - theta2)),
                            y: b.y + b.radius * Math.sin(angle + (Math.PI - theta2))
                        };
                        var cp0 = {
                            x: (tp1.x + tp2.x + tp3.x + tp4.x) / 4,
                            y: (tp1.y + tp2.y + tp3.y + tp4.y) / 4,
                        };
                        var cpRate = 0;
                        ;
                        //const surfaceDist = distance -sumRadius;
                        //const fusionSurfaceLimit = fusionLimit -sumRadius;
                        switch (fusionStatus) {
                            case "near":
                                cpRate = sumRadius + minRadius <= distance ?
                                    -Math.min(1, (distance - (sumRadius + minRadius)) / (fusionLimit - (sumRadius + minRadius))) :
                                    Math.min(1, (sumRadius + minRadius - distance) / (minRadius * 2));
                                break;
                            case "overlap":
                                cpRate = Math.min(1, (sumRadius + minRadius - distance) / (minRadius * 2));
                                break;
                        }
                        var cp1 = {
                            x: 0 <= cpRate ?
                                cp0.x * (1 - cpRate) + ((tp1.x + tp4.x) / 2) * cpRate :
                                cp0.x * (1 + cpRate) + ((tp2.x + tp3.x) / 2) * -cpRate,
                            y: 0 <= cpRate ?
                                cp0.y * (1 - cpRate) + ((tp1.y + tp4.y) / 2) * cpRate :
                                cp0.y * (1 + cpRate) + ((tp2.y + tp3.y) / 2) * -cpRate,
                        };
                        var cp2 = {
                            x: 0 <= cpRate ?
                                cp0.x * (1 - cpRate) + ((tp2.x + tp3.x) / 2) * cpRate :
                                cp0.x * (1 + cpRate) + ((tp1.x + tp4.x) / 2) * -cpRate,
                            y: 0 <= cpRate ?
                                cp0.y * (1 - cpRate) + ((tp2.y + tp3.y) / 2) * cpRate :
                                cp0.y * (1 + cpRate) + ((tp1.y + tp4.y) / 2) * -cpRate,
                        };
                        context.beginPath();
                        // ä¸Šå´ãƒ™ã‚¸ã‚§: tp1 -> cp -> tp3 (cpã¯ä¸­ç‚¹+ã‚ªãƒ•ã‚»ãƒƒãƒˆã§æ›²ã’)
                        context.moveTo(tp1.x, tp1.y);
                        var wireLength = distance - wireLimit;
                        if (0 < wireLength) // == "wired" === fusionStatus
                         {
                            var wireWidthAdjustRate = 1.15; // This adjustment is probably necessary because something is wrong somewhere,
                            // but I won't actively investigate the cause this time. (This isn't the only place where the animation isn't smooth.)
                            // If you want to smooth out this and other parts, first implement a verification mode
                            // that renders only two Units whose distance can be adjusted by the user.
                            var wireWidthRate = 1 - (wireLength / (fusionLimit - wireLimit));
                            var spikeMinHight = (Math.hypot(tp1.x - tp2.x, tp1.y - tp2.y) + Math.hypot(tp3.x - tp4.x, tp3.y - tp4.y)) / 8;
                            var fusionLength = Math.hypot(tp1.x - tp4.x, tp1.y - tp4.y);
                            var wireLengthRate = ((fusionLength - spikeMinHight * 2) * (1 - wireWidthRate)) / fusionLength;
                            var mp0a = geometry_js_1.Geometry.averagePoints([geometry_js_1.Geometry.mulPoint(geometry_js_1.Geometry.averagePoints([tp1, tp4]), wireWidthRate * wireWidthAdjustRate), geometry_js_1.Geometry.mulPoint(cp1, 2 - (wireWidthRate * wireWidthAdjustRate))]);
                            var mp1 = geometry_js_1.Geometry.addPoints(mp0a, geometry_js_1.Geometry.mulPoint(geometry_js_1.Geometry.subPoints(tp1, tp4), wireLengthRate * 0.5));
                            var cxp1 = geometry_js_1.Geometry.addPoints(mp0a, geometry_js_1.Geometry.mulPoint(geometry_js_1.Geometry.subPoints(tp1, tp4), (2 - wireWidthRate) / 4));
                            var cxp2 = geometry_js_1.Geometry.addPoints(mp0a, geometry_js_1.Geometry.mulPoint(geometry_js_1.Geometry.subPoints(tp4, tp1), (2 - wireWidthRate) / 4));
                            var mp2 = geometry_js_1.Geometry.addPoints(mp0a, geometry_js_1.Geometry.mulPoint(geometry_js_1.Geometry.subPoints(tp4, tp1), wireLengthRate * 0.5));
                            context.quadraticCurveTo(cxp1.x, cxp1.y, mp1.x, mp1.y);
                            context.lineTo(mp2.x, mp2.y);
                            context.quadraticCurveTo(cxp2.x, cxp2.y, tp4.x, tp4.y);
                            context.lineTo(tp3.x, tp3.y);
                            //const wireRate = wireLength / Math.hypot(tp3.x -tp2.x, tp3.y -tp2.y);
                            var mp0b = geometry_js_1.Geometry.averagePoints([geometry_js_1.Geometry.mulPoint(geometry_js_1.Geometry.averagePoints([tp3, tp2]), wireWidthRate * wireWidthAdjustRate), geometry_js_1.Geometry.mulPoint(cp2, 2 - (wireWidthRate * wireWidthAdjustRate))]);
                            var mp3 = geometry_js_1.Geometry.addPoints(mp0b, geometry_js_1.Geometry.mulPoint(geometry_js_1.Geometry.subPoints(tp3, tp2), wireLengthRate * 0.5));
                            var cxp3 = geometry_js_1.Geometry.addPoints(mp0b, geometry_js_1.Geometry.mulPoint(geometry_js_1.Geometry.subPoints(tp3, tp2), (2 - wireWidthRate) / 4));
                            var cxp4 = geometry_js_1.Geometry.addPoints(mp0b, geometry_js_1.Geometry.mulPoint(geometry_js_1.Geometry.subPoints(tp2, tp3), (2 - wireWidthRate) / 4));
                            var mp4 = geometry_js_1.Geometry.addPoints(mp0b, geometry_js_1.Geometry.mulPoint(geometry_js_1.Geometry.subPoints(tp2, tp3), wireLengthRate * 0.5));
                            context.quadraticCurveTo(cxp3.x, cxp3.y, mp3.x, mp3.y);
                            context.lineTo(mp4.x, mp4.y);
                            context.quadraticCurveTo(cxp4.x, cxp4.y, tp2.x, tp2.y);
                            //console.log({ wireRate, wireLength, distance, mp0a, mp1, cxp1, cxp2, mp2, mp0b, mp3, cxp3, cxp4, mp4, });
                        }
                        else {
                            context.quadraticCurveTo(cp1.x, cp1.y, tp4.x, tp4.y);
                            context.lineTo(tp3.x, tp3.y);
                            context.quadraticCurveTo(cp2.x, cp2.y, tp2.x, tp2.y);
                        }
                        context.lineTo(tp1.x, tp1.y);
                        context.fillStyle = color;
                        // connection.fillStyle = "#00000088";
                        context.fill();
                        context.closePath();
                    }
                }
            }
        };
        var drawCircle = function (circle, color) {
            if (0 <= circle.radius) {
                context.beginPath();
                context.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
                context.fillStyle = color;
                context.fill();
                context.closePath();
            }
        };
        var drawLayer = function (layer, color, coloring) {
            var canvasCircle = Render.getCanvasCircle();
            var bodies = layer.units.map(function (u) { return u.body; })
                .filter(function (c) { return !model_2.Model.isOutOfCanvas(c); })
                .map(function (c) { return mappingCircle(canvasCircle, c); });
            drawFusionPath(bodies, color);
            bodies.forEach(function (body) { return drawCircle(body, color); });
            if (layer === model_2.Model.Data.main) {
                var whites = layer.units
                    .filter(function (u) { return undefined !== u.eye && !model_2.Model.isOutOfCanvas(u.body); })
                    .map(function (u) { return mappingCircle(mappingCircle(canvasCircle, u.body), u.eye.white); });
                drawFusionPath(whites, coloring.base);
                whites.forEach(function (white) { return drawCircle(white, coloring.base); });
                var irises = layer.units
                    .filter(function (u) { return undefined !== u.eye && !model_2.Model.isOutOfCanvas(u.body); })
                    .map(function (u) { return mappingCircle(mappingCircle(canvasCircle, u.body), u.eye.iris); });
                drawFusionPath(irises, coloring.accent);
                irises.forEach(function (iris) { return drawCircle(iris, coloring.accent); });
            }
        };
        Render.draw = function (isUpdatedModel) {
            if (isRandomColoring() && config_json_3.default.rendering.randomColoringUnitDuration < (performance.now() - changedColoringAt)) {
                Render.updateColoring();
            }
            var coloring = getCurrentColors();
            var isColoringChanged = !isSameColoring(previousColors, coloring);
            if (isUpdatedModel || isColoringChanged) {
                previousColors = coloring;
                context.fillStyle = coloring.base;
                context.fillRect(0, 0, ui_1.UI.canvas.width, ui_1.UI.canvas.height);
                drawLayer(model_2.Model.Data.accent, coloring.accent, coloring);
                drawLayer(model_2.Model.Data.main, coloring.main, coloring);
            }
        };
    })(Render || (exports.Render = Render = {}));
});
define("script/fps", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Fps = void 0;
    var Fps;
    (function (Fps) {
        var OnlineStandardDeviation = /** @class */ (function () {
            function OnlineStandardDeviation() {
                var _this = this;
                this.count = 0;
                this.mean = 0;
                this.m2 = 0;
                this.reset = function () {
                    _this.count = 0;
                    _this.mean = 0;
                    _this.m2 = 0;
                };
                this.update = function (value) {
                    _this.count += 1;
                    var delta = value - _this.mean;
                    _this.mean += delta / _this.count;
                    var delta2 = value - _this.mean;
                    _this.m2 += delta * delta2;
                };
                this.isValid = function () { return 1 < _this.count; };
                this.getVariance = function () {
                    return _this.isValid() ? _this.m2 / (_this.count - 1) : 0;
                };
                this.getStandardDeviation = function () {
                    return Math.sqrt(_this.getVariance());
                };
            }
            return OnlineStandardDeviation;
        }());
        Fps.OnlineStandardDeviation = OnlineStandardDeviation;
        Fps.standardDeviation = new OnlineStandardDeviation();
        var fpsWindow = 1000; // ms
        var frameTimings = [];
        var fpsHistory = [];
        Fps.averageFps = NaN; // Stores the average FPS over the most recent 1 second
        var makeInvalidFpsHistoryEntry = function () {
            return ({
                fps: NaN,
                now: NaN,
                text: "N/A FPS",
            });
        };
        Fps.reset = function () {
            Fps.isValid = false;
            frameTimings = [];
            fpsHistory = [];
            Fps.currentMaxFps = Fps.currentNowFps = Fps.currentMinFps =
                makeInvalidFpsHistoryEntry();
            Fps.standardDeviation.reset();
            Fps.averageFps = NaN; // ãƒªã‚»ãƒƒãƒˆæ™‚ã«åˆæœŸåŒ–
        };
        Fps.step = function (now) {
            frameTimings.push(now);
            Fps.isValid = 2 <= frameTimings.length;
            if (Fps.isValid) {
                while (2 < frameTimings.length && fpsWindow < now - frameTimings[0]) {
                    frameTimings.shift();
                }
                var timeSpan = Math.max(now - frameTimings[0], 0.001); // max for avoid 0 div
                var frameCount = frameTimings.length - 1;
                var fps = (frameCount * 1000) / timeSpan;
                Fps.standardDeviation.update(fps);
                Fps.currentNowFps =
                    {
                        fps: fps,
                        now: now,
                        text: makeFpsText(fps),
                    };
                var expiredAt = now - fpsWindow;
                while (0 < fpsHistory.length && fpsHistory[0].now < expiredAt) {
                    fpsHistory.shift();
                }
                fpsHistory.push(Fps.currentNowFps);
                Fps.currentMaxFps = Fps.currentNowFps;
                Fps.currentMinFps = Fps.currentNowFps;
                fpsHistory.forEach(function (i) {
                    if (Fps.currentMaxFps.fps < i.fps) {
                        Fps.currentMaxFps = i;
                    }
                    if (i.fps < Fps.currentMinFps.fps) {
                        Fps.currentMinFps = i;
                    }
                });
                var totalFps = fpsHistory.map(function (i) { return i.fps; }).reduce(function (a, v) { return a + v; }, 0);
                Fps.averageFps = totalFps / fpsHistory.length;
                if (Fps.isUnderFuseFps()) {
                    console.error("âŒ UnderFuseFps:", {
                        fuseFps: Fps.fuseFps,
                        maxFps: Fps.currentMaxFps.fps,
                        nowFps: Fps.currentMaxFps.fps,
                        minFps: Fps.currentMinFps.fps,
                        averageFps: Fps.averageFps,
                    });
                }
            }
        };
        var makeFpsText = function (fps) {
            return "".concat(fps.toLocaleString("en-US", { useGrouping: false, maximumFractionDigits: 2, minimumFractionDigits: 2, }), " FPS");
        };
        Fps.getText = function () {
            var _a, _b;
            return ((_a = Fps.currentMaxFps === null || Fps.currentMaxFps === void 0 ? void 0 : Fps.currentMaxFps.text) !== null && _a !== void 0 ? _a : "N/A") + " (Max)\n"
                + "".concat(Fps.averageFps.toFixed(2), " FPS (Avg)\n")
                //+currentNowFps.text + " (Now)\n"
                + ((_b = Fps.currentMinFps === null || Fps.currentMinFps === void 0 ? void 0 : Fps.currentMinFps.text) !== null && _b !== void 0 ? _b : "N/A") + " (Min)";
        };
        Fps.isUnderFuseFps = function () { return Fps.isValid && Fps.currentMaxFps.fps < Fps.fuseFps; };
    })(Fps || (exports.Fps = Fps = {}));
});
define("script/event", ["require", "exports", "script/model", "script/render", "script/ui"], function (require, exports, model_3, render_1, ui_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Event = void 0;
    var Event;
    (function (Event) {
        Event.initialize = function () {
            window.addEventListener("resize", ui_2.UI.resize);
            window.addEventListener("orientationchange", ui_2.UI.resize);
            document.addEventListener("fullscreenchange", ui_2.UI.updateFullscreenState);
            document.addEventListener("webkitfullscreenchange", ui_2.UI.updateFullscreenState);
            document.addEventListener("mousemove", ui_2.UI.mousemove);
            var commandList = [
                {
                    key: "C",
                    button: ui_2.UI.coloringButton,
                    command: function (event) {
                        ui_2.UI.toggleColoring(!event.shiftKey);
                        render_1.Render.updateColoring();
                    }
                },
                {
                    key: "Q",
                    button: ui_2.UI.hdButton,
                    command: function (event) {
                        model_3.Model.togglePixelRatioMode(!event.shiftKey);
                        ui_2.UI.updateHdRoundBar();
                    }
                },
                {
                    key: "P",
                    button: ui_2.UI.pitchButton,
                    command: function (event) { return ui_2.UI.togglePitch(!event.shiftKey); },
                },
                {
                    key: "W",
                    button: ui_2.UI.watchButton,
                    command: function (event) { return ui_2.UI.toggleWatchDisplay(!event.shiftKey); }
                },
                {
                    key: "S",
                    button: ui_2.UI.fpsButton,
                    command: function () { return ui_2.UI.toggleFpsDisplay(); }
                },
                {
                    key: "F",
                    button: ui_2.UI.fullscreenButton,
                    command: function () { return ui_2.UI.toggleFullScreen(); }
                },
                {
                    button: ui_2.UI.jumpOutButton,
                    command: function () { return window.open(window.location.href, "_blank"); }
                }
            ];
            document.addEventListener("keydown", function (event) {
                if (!(event.metaKey || event.ctrlKey || event.altKey)) {
                    var command = commandList.find(function (cmd) { return cmd.key === event.key.toUpperCase(); });
                    if (command) {
                        event.preventDefault();
                        command.command(event);
                    }
                }
                ui_2.UI.mousemove();
            });
            commandList.forEach(function (command) {
                command.button.addEventListener("click", function (event) {
                    event.stopPropagation();
                    event.preventDefault();
                    command.command(event);
                    ui_2.UI.mousemove();
                });
            });
        };
    })(Event || (exports.Event = Event = {}));
});
define("script/watch", ["require", "exports", "script/url", "script/ui", "resource/config"], function (require, exports, url_1, ui_3, config_json_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Watch = void 0;
    config_json_4 = __importDefault(config_json_4);
    var Watch;
    (function (Watch) {
        Watch.locale = url_1.Url.params["locale"] || navigator.language;
        var phi = (1 + Math.sqrt(5)) / 2;
        Watch.makeDate = function (date, locale) {
            return date.toLocaleDateString(locale, config_json_4.default.watch.dateFormat);
        };
        Watch.makeTime = function (date, locale) {
            return date.toLocaleTimeString(locale, config_json_4.default.watch.timeFormat);
        };
        Watch.setColor = function (color) {
            ui_3.UI.setStyle(ui_3.UI.date, "color", color);
            ui_3.UI.setStyle(ui_3.UI.time, "color", color);
        };
        Watch.update = function () {
            if ("none" !== ui_3.UI.watchColor) {
                var date = new Date();
                ui_3.UI.setTextContent(ui_3.UI.time, Watch.makeTime(date, Watch.locale));
                ui_3.UI.setAttribute(ui_3.UI.time, "datatime", Watch.makeTime(date, "ja-JP"));
                ui_3.UI.setTextContent(ui_3.UI.date, Watch.makeDate(date, Watch.locale));
                ui_3.UI.setAttribute(ui_3.UI.date, "datatime", date.toISOString().slice(0, 10));
                switch (ui_3.UI.watchColor) {
                    case "white":
                        Watch.setColor("white");
                        break;
                    case "black":
                        Watch.setColor("black");
                        break;
                    case "rainbow":
                        Watch.setColor("hsl(".concat(((date.getTime() * 360) / (24000 * phi)).toFixed(2), "deg, 100%, 61%)"));
                        Watch.setColor("oklch(70% 0.18 ".concat(((date.getTime() * 360) / (24000 * phi)).toFixed(2), "deg)"));
                        break;
                }
            }
            else {
                ui_3.UI.setTextContent(ui_3.UI.time, "");
                ui_3.UI.setAttribute(ui_3.UI.time, "datatime", undefined);
                ui_3.UI.setTextContent(ui_3.UI.date, "");
                ui_3.UI.setAttribute(ui_3.UI.date, "datatime", undefined);
            }
        };
    })(Watch || (exports.Watch = Watch = {}));
});
define("script/index", ["require", "exports", "script/url", "script/model", "script/render", "script/fps", "script/ui", "script/event", "script/watch"], function (require, exports, url_2, model_4, render_2, fps_1, ui_4, event_1, watch_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    url_2.Url.initialize();
    event_1.Event.initialize();
    ui_4.UI.fpsDiv.style.display = "none";
    ui_4.UI.updateColoringRoundBar();
    ui_4.UI.updateHdRoundBar();
    ui_4.UI.updatePitchRoundBar();
    ui_4.UI.updateWatchVisibility();
    ui_4.UI.fullscreenButton.style.display = ui_4.UI.fullscreenEnabled ? "block" : "none";
    ui_4.UI.setAriaHidden(ui_4.UI.fullscreenButton, !ui_4.UI.fullscreenEnabled);
    ui_4.UI.updateFullscreenState();
    ui_4.UI.jumpOutButton.style.display = ui_4.UI.isInIframe ? "block" : "none";
    ui_4.UI.setAriaHidden(ui_4.UI.jumpOutButton, ui_4.UI.isInIframe);
    ui_4.UI.resize();
    var step = function (timestamp) {
        render_2.Render.draw(model_4.Model.updateData(timestamp));
        watch_1.Watch.update();
        if (ui_4.UI.fpsDiv.style.display !== "none") {
            fps_1.Fps.step(timestamp);
            ui_4.UI.fpsDiv.innerText = fps_1.Fps.getText();
        }
        window.requestAnimationFrame(step);
    };
    window.requestAnimationFrame(step);
});
//# sourceMappingURL=script/index.js.map
if ("serviceWorker" in navigator)
{
    window.addEventListener
    (
        "load",
        () =>
        {
            navigator.serviceWorker.register("./sw.js")
                .then(reg => console.log("âœ… SW registered:", reg.scope))
                .catch(err => console.warn("ðŸš« SW registration failed:", err));
        }
    );
}
</script>
</body>
</html>
